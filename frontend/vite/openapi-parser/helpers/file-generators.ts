/**
 * File content generators for OpenAPI documentation output.
 */

import type {
  GenComponentSchema,
  GenInfoSummary,
  GenOperationDetail,
  GenOperationSummary,
  GenTagSummary,
} from '../../../src/modules/docs/types';

const FILE_HEADER = '// This file is auto-generated by openapi-parser plugin';
const TYPES_IMPORT_PATH = '~/modules/docs/types';

/**
 * Creates a typed import statement for docs types.
 */
function createTypeImport(types: string[]): string {
  return `import type { ${types.join(', ')} } from '${TYPES_IMPORT_PATH}';`;
}

/**
 * Creates a typed const export with JSON-serialized value.
 */
function createConstExport(name: string, type: string, value: unknown): string {
  return `export const ${name}: ${type} = ${JSON.stringify(value, null, 2)};`;
}

/**
 * Builds a complete generated file with header, imports, and content.
 */
function buildGeneratedFile(parts: { imports?: string[]; content: string }): string {
  const sections = [FILE_HEADER];

  if (parts.imports?.length) {
    sections.push(createTypeImport(parts.imports));
  }

  sections.push(parts.content);

  return `${sections.join('\n')}\n`;
}

// ============================================================================
// Public API - File Generators
// ============================================================================

/**
 * Generate a Scalar-like hash for an operation.
 * Format: tag/{tagName}/{METHOD}{path}
 * Example: tag/system/POST/system/paddle-webhook
 */
export function generateOperationHash(method: string, path: string, tags: string[]): string {
  const tag = tags[0] || 'default';
  // Remove leading slash and convert path for hash
  const cleanPath = path.startsWith('/') ? path.slice(1) : path;
  return `tag/${tag}/${method.toUpperCase()}/${cleanPath}`;
}

/**
 * Generate the operations file content.
 */
export function generateOperationsFile(operations: GenOperationSummary[]): string {
  return buildGeneratedFile({
    imports: ['GenOperationSummary'],
    content: createConstExport('operations', 'GenOperationSummary[]', operations),
  });
}

/**
 * Generate the info file content.
 */
export function generateInfoFile(info: GenInfoSummary): string {
  return buildGeneratedFile({
    imports: ['GenInfoSummary'],
    content: createConstExport('info', 'GenInfoSummary', info),
  });
}

/**
 * Generate the tags file content with tag names tuple for type-safe validation.
 */
export function generateTagsFile(tags: GenTagSummary[]): string {
  const tagNamesArray = tags.map((t) => `'${t.name}'`).join(', ');

  const content = `/**
 * Tag names as const tuple for type-safe enum validation
 */
export const tagNames = [${tagNamesArray}] as const;

export type TagName = (typeof tagNames)[number];

${createConstExport('tags', 'GenTagSummary[]', tags)}`;

  return buildGeneratedFile({
    imports: ['GenTagSummary'],
    content,
  });
}

/**
 * Generate the tag details file content for a specific tag.
 */
export function generateTagDetailsFile(tagName: string, operations: GenOperationDetail[]): string {
  const content = `export const tagName = '${tagName}' as const;

${createConstExport('operations', 'GenOperationDetail[]', operations)}`;

  return buildGeneratedFile({
    imports: ['GenOperationDetail'],
    content,
  });
}

/**
 * Generate the schemas file content with schema tags metadata.
 */
export function generateSchemasFile(
  schemas: GenComponentSchema[],
  schemaTags: { name: string; description: string; count: number }[],
): string {
  const schemaTagNames = schemaTags.map((t) => `'${t.name}'`).join(', ');

  const content = `export const schemaTagNames = [${schemaTagNames}] as const;

${createConstExport('schemaTags', '{ name: SchemaTag; description: string; count: number }[]', schemaTags)}

${createConstExport('schemas', 'GenComponentSchema[]', schemas)}`;

  return buildGeneratedFile({
    imports: ['GenComponentSchema', 'SchemaTag'],
    content,
  });
}

/**
 * Generate the index file content that exports all generated files.
 */
export function generateIndexFile(tagNames: string[]): string {
  const tagExports = tagNames.map((name) => `export * as ${name} from './details/${name}.gen';`).join('\n');

  return `${FILE_HEADER}

// Re-export types from central location
export type { GenComponentSchema, GenInfoSummary, GenOperationDetail, GenOperationSummary, GenResponseSummary, GenTagSummary, SchemaTag } from '${TYPES_IMPORT_PATH}';

export * from './info.gen';
export * from './operations.gen';
export * from './schemas.gen';
export * from './tags.gen';

// Per-tag operation details (lazy-loadable)
${tagExports}
`;
}
