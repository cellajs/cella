import { mkdirSync, writeFileSync } from 'node:fs';
import { resolve } from 'node:path';
import type { DefinePlugin } from '@hey-api/openapi-ts';
import { definePluginConfig } from '@hey-api/openapi-ts';

/**
 * OpenAPI Parser Plugin for API Documentation
 *
 * Transforms OpenAPI spec into lightweight operation summaries for docs UI.
 * Generates two arrays:
 * - operations: Minimal data for table rows and sidebar
 * - tags: Tag metadata with operation counts
 *
 * Secondary data (full descriptions, parameters, schemas) is accessed
 * on-demand from the full OpenAPI spec.
 */

/**
 * Configuration options for the openapi-parser plugin.
 */
type Config = {
  name: 'openapi-parser';
  output?: string;
};

type OpenApiParserPlugin = DefinePlugin<Config>;

/**
 * Operation summary with minimal data for table/sidebar rendering
 */
interface OperationSummary {
  id: string;
  hash: string;
  method: string;
  path: string;
  tags: string[];
  summary: string;
  description: string;
  deprecated: boolean;
  hasAuth: boolean;
  hasParams: boolean;
  hasRequestBody: boolean;
}

/**
 * Generate a Scalar-like hash for an operation
 * Format: tag/{tagName}/{METHOD}{path}
 * Example: tag/system/POST/system/paddle-webhook
 */
function generateOperationHash(method: string, path: string, tags: string[]): string {
  const tag = tags[0] || 'default';
  // Remove leading slash and convert path for hash
  const cleanPath = path.startsWith('/') ? path.slice(1) : path;
  return `tag/${tag}/${method.toUpperCase()}/${cleanPath}`;
}

/**
 * Tag summary with operation count
 */
interface TagSummary {
  name: string;
  description?: string;
  count: number;
}

/**
 * OpenAPI info summary
 */
interface InfoSummary {
  title: string;
  version: string;
  description: string;
  openapiVersion: string;
}

/**
 * Response summary for operation details
 */
interface ResponseSummary {
  status: number;
  description: string;
}

/**
 * Detailed operation info (for lazy loading per tag)
 */
interface OperationDetail {
  operationId: string;
  responses: ResponseSummary[];
}

/**
 * Generate the operations file content
 */
function generateOperationsFile(operations: OperationSummary[]): string {
  return `// This file is auto-generated by openapi-parser plugin

export interface OperationSummary {
  id: string;
  hash: string;
  method: string;
  path: string;
  tags: string[];
  summary: string;
  description: string;
  deprecated: boolean;
  hasAuth: boolean;
  hasParams: boolean;
  hasRequestBody: boolean;
}

export const operations: OperationSummary[] = ${JSON.stringify(operations, null, 2)};
`;
}

/**
 * Generate the tags file content
 */
function generateTagsFile(tags: TagSummary[]): string {
  const tagNamesArray = tags.map((t) => `'${t.name}'`).join(', ');
  return `// This file is auto-generated by openapi-parser plugin

export interface TagSummary {
  name: string;
  description?: string;
  count: number;
}

/**
 * Tag names as const tuple for type-safe enum validation
 */
export const tagNames = [${tagNamesArray}] as const;

export type TagName = (typeof tagNames)[number];

export const tags: TagSummary[] = ${JSON.stringify(tags, null, 2)};
`;
}

/**
 * Generate the info file content
 */
function generateInfoFile(info: InfoSummary): string {
  return `// This file is auto-generated by openapi-parser plugin

export interface InfoSummary {
  title: string;
  version: string;
  description: string;
  openapiVersion: string;
}

export const info: InfoSummary = ${JSON.stringify(info, null, 2)};
`;
}

/**
 * Generate the tag details file content for a specific tag
 */
function generateTagDetailsFile(tagName: string, operations: OperationDetail[]): string {
  return `// This file is auto-generated by openapi-parser plugin

export interface ResponseSummary {
  status: number;
  description: string;
}

export interface OperationDetail {
  operationId: string;
  responses: ResponseSummary[];
}

export const tagName = '${tagName}' as const;

export const operations: OperationDetail[] = ${JSON.stringify(operations, null, 2)};
`;
}

/**
 * Handler function for the openapi-parser plugin
 */
const handler: OpenApiParserPlugin['Handler'] = ({ plugin }) => {
  const operations: OperationSummary[] = [];
  const tagMap = new Map<string, { description?: string; count: number }>();
  // Track detailed operation info per tag for lazy-loaded files
  const tagDetailsMap = new Map<string, OperationDetail[]>();

  // Get the raw OpenAPI spec to access original descriptions
  const spec = plugin.context.spec;

  // Get tag descriptions from the OpenAPI spec directly
  if (spec.tags) {
    for (const tag of spec.tags) {
      tagMap.set(tag.name, { description: tag.description, count: 0 });
    }
  }

  // Iterate through spec.paths directly to preserve order
  const validMethods = new Set(['get', 'post', 'put', 'delete', 'patch', 'options', 'head']);

  if (spec.paths) {
    for (const [path, pathItem] of Object.entries(spec.paths)) {
      if (!pathItem) continue;

      // Iterate in the order the methods appear in pathItem
      for (const [method, operation] of Object.entries(pathItem as Record<string, unknown>)) {
        if (!validMethods.has(method)) continue;

        const op = operation as {
          operationId?: string;
          description?: string;
          summary?: string;
          tags?: string[];
          deprecated?: boolean;
          security?: unknown[];
          parameters?: Record<string, unknown>;
          requestBody?: unknown;
          responses?: Record<string, { description?: string; $ref?: string }>;
        };

        if (!op?.operationId) continue;

        const tags = op.tags ?? [];

        // Helper to resolve $ref to component responses
        const componentResponses = (spec.components?.responses ?? {}) as Record<string, { description?: string }>;

        // Extract responses for operation details
        const responses: ResponseSummary[] = [];
        if (op.responses) {
          for (const [statusCode, response] of Object.entries(op.responses)) {
            let description = response?.description ?? '';

            // Resolve $ref if present (e.g., "#/components/responses/BadRequestError")
            if (response?.$ref) {
              const refName = response.$ref.split('/').pop();
              if (refName && componentResponses[refName]) {
                description = componentResponses[refName].description ?? '';
              }
            }

            responses.push({
              status: Number.parseInt(statusCode, 10),
              description,
            });
          }
        }

        const operationSummary: OperationSummary = {
          id: op.operationId,
          hash: generateOperationHash(method, path, tags),
          method,
          path,
          tags,
          summary: op.summary ?? '',
          description: op.description ?? '',
          deprecated: op.deprecated ?? false,
          hasAuth: (op.security?.length ?? 0) > 0,
          hasParams: Object.keys(op.parameters ?? {}).length > 0,
          hasRequestBody: !!op.requestBody,
        };

        operations.push(operationSummary);

        // Create operation detail for per-tag files
        const operationDetail: OperationDetail = {
          operationId: op.operationId,
          responses,
        };

        // Count operations per tag and store details
        for (const tag of tags) {
          const existing = tagMap.get(tag);
          if (existing) {
            existing.count++;
          } else {
            // Tag not in spec but used in operations
            tagMap.set(tag, { count: 1 });
          }

          // Store operation detail for this tag
          const tagDetails = tagDetailsMap.get(tag);
          if (tagDetails) {
            tagDetails.push(operationDetail);
          } else {
            tagDetailsMap.set(tag, [operationDetail]);
          }
        }
      }
    }
  }

  // Convert tag map to array (maintain order from spec)
  const tags: TagSummary[] = Array.from(tagMap.entries()).map(([name, data]) => ({
    name,
    description: data.description || undefined,
    count: data.count,
  }));

  // Extract OpenAPI info
  const specInfo = spec.info || {};
  const info: InfoSummary = {
    title: specInfo.title ?? '',
    version: specInfo.version ?? '',
    description: specInfo.description ?? '',
    openapiVersion: spec.openapi ?? '',
  };

  // Generate the output files
  const operationsContent = generateOperationsFile(operations);
  const tagsContent = generateTagsFile(tags);
  const infoContent = generateInfoFile(info);

  // Create docs directory
  const docsDir = resolve(plugin.context.config.output.path, 'docs');
  mkdirSync(docsDir, { recursive: true });

  // Create details subdirectory for per-tag detail files
  const detailsDir = resolve(docsDir, 'details');
  mkdirSync(detailsDir, { recursive: true });

  // Generate per-tag detail files
  const tagNames: string[] = [];
  for (const [tagName, tagOperations] of tagDetailsMap.entries()) {
    const tagDetailsContent = generateTagDetailsFile(tagName, tagOperations);
    const tagFilePath = resolve(detailsDir, `${tagName}.gen.ts`);
    writeFileSync(tagFilePath, tagDetailsContent, 'utf-8');
    tagNames.push(tagName);
  }

  // Generate index file with exports for all files
  const tagExports = tagNames.map((name) => `export * as ${name} from './details/${name}.gen';`).join('\n');
  const indexContent = `// This file is auto-generated by openapi-parser plugin

export * from './info.gen';
export * from './operations.gen';
export * from './tags.gen';

// Per-tag operation details (lazy-loadable)
${tagExports}
`;

  // Write files to docs directory
  const operationsPath = resolve(docsDir, 'operations.gen.ts');
  const tagsPath = resolve(docsDir, 'tags.gen.ts');
  const infoPath = resolve(docsDir, 'info.gen.ts');
  const indexPath = resolve(docsDir, 'index.ts');

  writeFileSync(operationsPath, operationsContent, 'utf-8');
  writeFileSync(tagsPath, tagsContent, 'utf-8');
  writeFileSync(infoPath, infoContent, 'utf-8');
  writeFileSync(indexPath, indexContent, 'utf-8');
};

/**
 * Default plugin configuration
 */
export const defaultConfig: OpenApiParserPlugin['Config'] = {
  dependencies: ['@hey-api/typescript'],
  handler,
  name: 'openapi-parser',
  config: {
    output: 'docs-operations',
  },
};

/**
 * Plugin factory function
 */
export const defineConfig = definePluginConfig(defaultConfig);

export default defineConfig;
