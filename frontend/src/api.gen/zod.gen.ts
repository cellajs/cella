// This file is auto-generated by @hey-api/openapi-ts

import * as z from 'zod';

/**
 * Minimal user data for references (e.g. createdBy, modifiedBy).
 */
export const zUserMinimalBase = z.object({
  id: z.string(),
  name: z.string(),
  slug: z.string(),
  thumbnailUrl: z.string().nullable(),
  email: z.email(),
  entityType: z.enum(['user']),
});

/**
 * Base user schema with essential fields for identification and display.
 */
export const zUserBase = z.object({
  id: z.string(),
  name: z.string(),
  createdAt: z.string(),
  modifiedAt: z.string().nullable(),
  slug: z.string(),
  thumbnailUrl: z.string().nullable(),
  bannerUrl: z.string().nullable(),
  description: z.string().nullable(),
  email: z.email(),
  entityType: z.enum(['user']),
});

/**
 * Base schema for entities with memberships (e.g. organization).
 */
export const zContextEntityBase = z.object({
  id: z.string(),
  name: z.string(),
  createdAt: z.string(),
  modifiedAt: z.string().nullable(),
  tenantId: z.string(),
  entityType: z.enum(['organization']),
  slug: z.string(),
  thumbnailUrl: z.string().nullable(),
  bannerUrl: z.string().nullable(),
});

/**
 * Core membership fields shared across active and inactive memberships.
 */
export const zMembershipBase = z.object({
  id: z.string().max(50),
  tenantId: z.string().max(24),
  contextType: z.enum(['organization']),
  userId: z.string().max(50),
  role: z.enum(['admin', 'member']),
  archived: z.boolean(),
  muted: z.boolean(),
  displayOrder: z.number().gte(-140737488355328).lte(140737488355327),
  organizationId: z.string().max(50),
});

/**
 * Sync transaction metadata stored on entities for offline and realtime support.
 */
export const zStxBase = z.object({
  mutationId: z.string(),
  sourceId: z.string(),
  version: z.int(),
  fieldVersions: z.record(z.string(), z.int()),
});

/**
 * Realtime notification delivered via SSE for entity and membership changes.
 */
export const zStreamNotification = z.object({
  action: z.enum(['create', 'update', 'delete']),
  entityType: z.enum(['attachment', 'page']).nullable(),
  resourceType: z.enum(['request', 'membership', 'inactive_membership', 'tenant']).nullable(),
  entityId: z.string(),
  organizationId: z.string().nullable(),
  contextType: z.enum(['organization']).nullable(),
  seq: z.int().nullable(),
  stx: zStxBase.and(z.record(z.string(), z.unknown())).nullable(),
  cacheToken: z.string().nullable(),
});

/**
 * Error info for failed CDC activities (dead letters).
 */
export const zActivityError = z.object({
  lsn: z.string(),
  message: z.string(),
  code: z.string().nullish(),
  retryCount: z.number(),
  resolved: z.boolean().optional(),
});

/**
 * Standard error response returned by all API endpoints.
 */
export const zApiError = z.object({
  name: z.string(),
  message: z.string(),
  type: z.string(),
  status: z.int().gte(400).lte(599),
  severity: z.enum(['fatal', 'error', 'warn', 'info', 'debug', 'trace']),
  entityType: z.enum(['user', 'organization', 'attachment', 'page']).optional(),
  logId: z.string().optional(),
  path: z.string().optional(),
  method: z.string().optional(),
  timestamp: z.string().optional(),
  userId: z.string().optional(),
  organizationId: z.string().optional(),
});

/**
 * Error returned when the request is malformed or contains invalid data.
 */
export const zBadRequestError = zApiError.and(
  z.object({
    status: z.literal(400).optional(),
  }),
);

/**
 * Error returned when authentication is missing or invalid.
 */
export const zUnauthorizedError = zApiError.and(
  z.object({
    status: z.literal(401).optional(),
  }),
);

/**
 * Error returned when the user lacks permission for the requested action.
 */
export const zForbiddenError = zApiError.and(
  z.object({
    status: z.literal(403).optional(),
  }),
);

/**
 * Error returned when the requested resource cannot be found.
 */
export const zNotFoundError = zApiError.and(
  z.object({
    status: z.literal(404).optional(),
  }),
);

/**
 * Error returned when rate limits are exceeded.
 */
export const zTooManyRequestsError = zApiError.and(
  z.object({
    status: z.literal(429).optional(),
  }),
);

/**
 * An auditable event recording an entity change, used for sync and history.
 */
export const zActivity = z.object({
  id: z.string().max(50),
  tenantId: z.string().max(24).nullable(),
  userId: z.string().max(50).nullable(),
  entityType: z.enum(['user', 'organization', 'attachment', 'page']).nullable(),
  resourceType: z.enum(['request', 'membership', 'inactive_membership', 'tenant']).nullable(),
  action: z.enum(['create', 'update', 'delete']),
  tableName: z.string().max(255),
  type: z.string().max(255),
  entityId: z.string().max(50).nullable(),
  organizationId: z.string().max(50).nullable(),
  createdAt: z.string(),
  changedKeys: z.array(z.string()).nullable(),
  stx: zStxBase.nullable(),
  seq: z.int().gte(-2147483648).lte(2147483647).nullable(),
  error: zActivityError.nullable(),
});

/**
 * A user with profile data and activity timestamps.
 */
export const zUser = z.object({
  createdAt: z.string(),
  id: z.string().max(50),
  entityType: z.enum(['user']),
  name: z.string().max(255),
  description: z.string().nullable(),
  slug: z.string().max(255),
  thumbnailUrl: z.string().max(2048).nullable(),
  bannerUrl: z.string().max(2048).nullable(),
  email: z.email(),
  mfaRequired: z.boolean(),
  firstName: z.string().max(255).nullable(),
  lastName: z.string().max(255).nullable(),
  language: z.enum(['en', 'nl']),
  newsletter: z.boolean(),
  userFlags: z.object({
    finishedOnboarding: z.boolean(),
  }),
  modifiedAt: z.string().nullable(),
  modifiedBy: z.string().max(50).nullable(),
  lastSeenAt: z.string().nullable(),
  lastStartedAt: z.string().nullable(),
  lastSignInAt: z.string().nullable(),
});

/**
 * The currently authenticated user with their system admin status.
 */
export const zMe = z.object({
  user: zUser,
  isSystemAdmin: z.boolean(),
});

/**
 * Authentication metadata for the current user session.
 */
export const zMeAuthData = z.object({
  enabledOAuth: z.array(z.enum(['github'])),
  hasTotp: z.boolean(),
  hasPassword: z.boolean(),
  sessions: z.array(
    z.object({
      id: z.string().max(50),
      type: z.enum(['regular', 'impersonation', 'mfa']),
      userId: z.string().max(50),
      deviceName: z.string().max(255).nullable(),
      deviceType: z.enum(['desktop', 'mobile']),
      deviceOs: z.string().max(255).nullable(),
      browser: z.string().max(255).nullable(),
      authStrategy: z.enum(['github', 'google', 'microsoft', 'password', 'passkey', 'totp', 'email']),
      createdAt: z.string(),
      expiresAt: z.string(),
      isCurrent: z.boolean(),
    }),
  ),
  passkeys: z.array(
    z.object({
      id: z.string().max(50),
      userId: z.string().max(50),
      deviceName: z.string().max(255).nullable(),
      deviceType: z.enum(['desktop', 'mobile']),
      deviceOs: z.string().max(255).nullable(),
      browser: z.string().max(255).nullable(),
      nameOnDevice: z.string().max(255),
      createdAt: z.string(),
    }),
  ),
});

/**
 * A membership record for a user who has not yet accepted an invitation.
 */
export const zInactiveMembership = z.object({
  createdAt: z.string(),
  id: z.string().max(50),
  tenantId: z.string().max(24),
  contextType: z.enum(['organization']),
  email: z.string().max(255),
  userId: z.string().max(50).nullable(),
  tokenId: z.string().max(50).nullable(),
  role: z.enum(['admin', 'member']),
  rejectedAt: z.string().nullable(),
  createdBy: zUserMinimalBase.and(z.record(z.string(), z.unknown())).nullable(),
  organizationId: z.string().max(50),
});

/**
 * A signed token authorizing file uploads to the configured storage provider.
 */
export const zUploadToken = z.object({
  public: z.boolean(),
  sub: z.string(),
  s3: z.boolean(),
  signature: z.string().nullable(),
  params: z
    .object({
      auth: z.object({
        key: z.string(),
        expires: z.string().optional(),
      }),
    })
    .nullable(),
});

/**
 * A tenant representing an isolated data partition for multi-tenancy.
 */
export const zTenant = z.object({
  id: z.string().max(24),
  name: z.string(),
  status: z.enum(['active', 'suspended', 'archived']),
  restrictions: z.object({
    quotas: z.record(z.string(), z.int().gte(0)),
    rateLimits: z.object({
      apiPointsPerHour: z.int().gte(0),
    }),
  }),
  createdAt: z.string(),
  modifiedAt: z.string().nullable(),
});

/**
 * A contact or waitlist submission from an unauthenticated user.
 */
export const zRequest = z.object({
  createdAt: z.string(),
  id: z.string().max(50),
  message: z.string().max(255).nullable(),
  email: z.string().max(255),
  type: z.enum(['waitlist', 'newsletter', 'contact']),
  wasInvited: z.boolean(),
});

/**
 * An organization with membership context.
 */
export const zOrganization = z.object({
  createdAt: z.string(),
  id: z.string().max(50),
  entityType: z.enum(['organization']),
  tenantId: z.string().max(24),
  name: z.string().max(255),
  modifiedAt: z.string().nullable(),
  slug: z.string().max(255),
  thumbnailUrl: z.string().max(2048).nullable(),
  bannerUrl: z.string().max(2048).nullable(),
  createdBy: zUserMinimalBase.and(z.record(z.string(), z.unknown())).nullable(),
  modifiedBy: zUserMinimalBase.and(z.record(z.string(), z.unknown())).nullable(),
  shortName: z.string().max(255).nullable(),
  country: z.string().max(255).nullable(),
  timezone: z.string().max(255).nullable(),
  defaultLanguage: z.enum(['en', 'nl']),
  languages: z.array(z.enum(['en', 'nl'])).min(1),
  notificationEmail: z.string().max(255).nullable(),
  emailDomains: z.array(z.string()),
  color: z.string().max(255).nullable(),
  logoUrl: z.string().max(2048).nullable(),
  websiteUrl: z.string().max(2048).nullable(),
  welcomeText: z.string().max(1000000).nullable(),
  authStrategies: z.array(z.enum(['github', 'google', 'microsoft', 'password', 'passkey', 'totp', 'email'])),
  chatSupport: z.boolean(),
  included: z.object({
    membership: zMembershipBase.optional(),
    counts: z
      .object({
        membership: z.object({
          admin: z.number(),
          member: z.number(),
          pending: z.number(),
          total: z.number(),
        }),
        entities: z.object({
          attachment: z.number(),
          page: z.number(),
        }),
      })
      .optional(),
  }),
});

/**
 * A content page for documentation purposes.
 */
export const zPage = z.object({
  createdAt: z.string(),
  id: z.string().max(50),
  entityType: z.enum(['page']),
  tenantId: z.string().max(24),
  name: z.string().max(255),
  modifiedAt: z.string().nullable(),
  stx: zStxBase,
  description: z.string().max(1000000).nullable(),
  keywords: z.string().max(1000000),
  createdBy: zUserMinimalBase.and(z.record(z.string(), z.unknown())).nullable(),
  modifiedBy: zUserMinimalBase.and(z.record(z.string(), z.unknown())).nullable(),
  status: z.enum(['unpublished', 'published', 'archived']),
  publicAccess: z.boolean(),
  parentId: z.string().max(50).nullable(),
  displayOrder: z.number().gte(-140737488355328).lte(140737488355327),
});

/**
 * Sync transaction metadata sent with mutations for idempotency and conflict detection.
 */
export const zStxRequestBase = z.object({
  mutationId: z.string().max(32),
  sourceId: z.string().max(64),
  lastReadVersion: z.int().gte(0),
});

/**
 * A file attachment belonging to an organization.
 */
export const zAttachment = z.object({
  createdAt: z.string(),
  id: z.string().max(50),
  entityType: z.enum(['attachment']),
  tenantId: z.string().max(24),
  name: z.string().max(255),
  modifiedAt: z.string().nullable(),
  stx: zStxBase,
  description: z.string().max(1000000).nullable(),
  keywords: z.string().max(1000000),
  createdBy: zUserMinimalBase.and(z.record(z.string(), z.unknown())).nullable(),
  modifiedBy: zUserMinimalBase.and(z.record(z.string(), z.unknown())).nullable(),
  public: z.boolean(),
  bucketName: z.string().max(255),
  groupId: z.string().max(50).nullable(),
  filename: z.string().max(255),
  contentType: z.string().max(255),
  convertedContentType: z.string().max(255).nullable(),
  size: z.string().max(255),
  originalKey: z.string().max(2048),
  convertedKey: z.string().max(2048).nullable(),
  thumbnailKey: z.string().max(2048).nullable(),
  organizationId: z.string().max(50),
  viewCount: z.int().gte(0).optional(),
});

/**
 * A user's membership in a context entity, including role and activity data.
 */
export const zMembership = z.object({
  createdAt: z.string(),
  id: z.string().max(50),
  tenantId: z.string().max(24),
  contextType: z.enum(['organization']),
  userId: z.string().max(50),
  role: z.enum(['admin', 'member']),
  createdBy: z.string().max(50),
  modifiedAt: z.string().nullable(),
  modifiedBy: z.string().max(50).nullable(),
  archived: z.boolean(),
  muted: z.boolean(),
  displayOrder: z.number().gte(-140737488355328).lte(140737488355327),
  organizationId: z.string().max(50),
});

export const zGetActivitiesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z
    .object({
      q: z.string().max(255).optional(),
      sort: z.enum(['createdAt', 'type', 'tableName']).optional(),
      order: z.enum(['asc', 'desc']).optional(),
      offset: z.string().optional(),
      limit: z.string().optional(),
      userId: z.string().max(50).nullish(),
      entityType: z.enum(['user', 'organization', 'attachment', 'page']).optional(),
      resourceType: z.enum(['request', 'membership', 'inactive_membership', 'tenant']).optional(),
      action: z.enum(['create', 'update', 'delete']).optional(),
      tableName: z.string().max(255).optional(),
      type: z.string().max(255).optional(),
      entityId: z.string().max(50).nullish(),
    })
    .optional(),
});

/**
 * Activities
 */
export const zGetActivitiesResponse = z.object({
  items: z.array(zActivity),
  total: z.number(),
});

export const zGetAuthHealthData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Auth health status
 */
export const zGetAuthHealthResponse = z.object({
  restrictedMode: z.boolean(),
  retryAfter: z.number().optional(),
});

export const zCheckEmailData = z.object({
  body: z.object({
    email: z.email(),
  }),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Email exists
 */
export const zCheckEmailResponse = z.void();

export const zInvokeTokenData = z.object({
  body: z.never().optional(),
  path: z.object({
    type: z.enum(['email-verification', 'oauth-verification', 'password-reset', 'invitation', 'confirm-mfa']),
    token: z.string(),
  }),
  query: z.never().optional(),
});

export const zGetTokenDataData = z.object({
  body: z.never().optional(),
  path: z.object({
    type: z.enum(['email-verification', 'oauth-verification', 'password-reset', 'invitation', 'confirm-mfa']),
    id: z.string().max(50),
  }),
  query: z.never().optional(),
});

/**
 * Token is valid
 */
export const zGetTokenDataResponse = z.object({
  email: z.email(),
  userId: z.string().optional(),
  inactiveMembershipId: z.string().optional(),
});

export const zStartImpersonationData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    targetUserId: z.string(),
  }),
});

/**
 * Impersonating
 */
export const zStartImpersonationResponse = z.void();

export const zStopImpersonationData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Stopped impersonating
 */
export const zStopImpersonationResponse = z.void();

export const zResendInvitationWithTokenData = z.object({
  body: z.union([
    z.object({
      email: z.email(),
      tokenId: z.string().optional(),
    }),
    z.object({
      email: z.email().optional(),
      tokenId: z.string(),
    }),
  ]),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Invitation email sent
 */
export const zResendInvitationWithTokenResponse = z.void();

export const zSignOutData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * User signed out
 */
export const zSignOutResponse = z.void();

export const zGenerateTotpKeyData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Challenge created
 */
export const zGenerateTotpKeyResponse = z.object({
  totpUri: z.string(),
  manualKey: z.string(),
});

export const zDeleteTotpData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * TOTP deleted
 */
export const zDeleteTotpResponse = z.void();

export const zCreateTotpData = z.object({
  body: z.object({
    code: z.string().regex(/^\d{6}$/),
  }),
  path: z.never().optional(),
  query: z.never().optional(),
});

export const zSignInWithTotpData = z.object({
  body: z.object({
    code: z.string().regex(/^\d{6}$/),
  }),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * TOTP verified
 */
export const zSignInWithTotpResponse = z.void();

export const zSignUpData = z.object({
  body: z
    .object({
      email: z.email(),
      password: z.string().min(8).max(100),
    })
    .optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

export const zSignUpWithTokenData = z.object({
  body: z.object({
    email: z.email(),
    password: z.string().min(8).max(100),
  }),
  path: z.object({
    tokenId: z.string(),
  }),
  query: z.never().optional(),
});

/**
 * User signed up
 */
export const zSignUpWithTokenResponse = z.object({
  membershipInvite: z.boolean(),
});

export const zRequestPasswordData = z.object({
  body: z.object({
    email: z.email(),
  }),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Password reset email sent
 */
export const zRequestPasswordResponse = z.void();

export const zCreatePasswordData = z.object({
  body: z.object({
    password: z.string().min(8).max(100),
  }),
  path: z.object({
    tokenId: z.string(),
  }),
  query: z.never().optional(),
});

/**
 * Password created
 */
export const zCreatePasswordResponse = z.object({
  mfa: z.boolean(),
});

export const zSignInData = z.object({
  body: z.object({
    email: z.email(),
    password: z.string().min(8).max(100),
  }),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * User signed in
 */
export const zSignInResponse = z.object({
  emailVerified: z.boolean(),
  mfa: z.boolean().optional(),
});

export const zCreatePasskeyData = z.object({
  body: z.object({
    attestationObject: z.string(),
    clientDataJSON: z.string(),
    nameOnDevice: z.string().max(255),
  }),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Passkey created
 */
export const zCreatePasskeyResponse = z.object({
  id: z.string().max(50),
  userId: z.string().max(50),
  deviceName: z.string().max(255).nullable(),
  deviceType: z.enum(['desktop', 'mobile']),
  deviceOs: z.string().max(255).nullable(),
  browser: z.string().max(255).nullable(),
  nameOnDevice: z.string().max(255),
  createdAt: z.string(),
});

export const zDeletePasskeyData = z.object({
  body: z.never().optional(),
  path: z.object({
    id: z.string().max(50),
  }),
  query: z.never().optional(),
});

/**
 * Passkey deleted
 */
export const zDeletePasskeyResponse = z.void();

export const zGeneratePasskeyChallengeData = z.object({
  body: z.object({
    type: z.enum(['authentication', 'mfa', 'registration']),
    email: z.string().max(255).optional(),
  }),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Challenge generated
 */
export const zGeneratePasskeyChallengeResponse = z.object({
  challengeBase64: z.string(),
  credentialIds: z.array(z.string()),
});

export const zSignInWithPasskeyData = z.object({
  body: z.object({
    credentialId: z.string(),
    clientDataJSON: z.string(),
    authenticatorObject: z.string(),
    signature: z.string(),
    type: z.enum(['authentication', 'mfa']),
    email: z.string().max(255).optional(),
  }),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Passkey verified
 */
export const zSignInWithPasskeyResponse = z.void();

export const zGithubData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z
    .object({
      type: z.enum(['auth', 'connect', 'invite', 'verify']).optional(),
      redirectAfter: z.string().optional(),
    })
    .optional(),
});

export const zGoogleData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z
    .object({
      type: z.enum(['auth', 'connect', 'invite', 'verify']).optional(),
      redirectAfter: z.string().optional(),
    })
    .optional(),
});

export const zMicrosoftData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z
    .object({
      type: z.enum(['auth', 'connect', 'invite', 'verify']).optional(),
      redirectAfter: z.string().optional(),
    })
    .optional(),
});

export const zGithubCallbackData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    code: z.string(),
    state: z.string(),
    error: z.string().optional(),
    error_description: z.string().optional(),
    error_uri: z.string().optional(),
  }),
});

export const zGoogleCallbackData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    code: z.string(),
    state: z.string(),
  }),
});

export const zMicrosoftCallbackData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    code: z.string(),
    state: z.string(),
  }),
});

export const zDeleteMeData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * User deleted
 */
export const zDeleteMeResponse = z.void();

export const zGetMeData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * User
 */
export const zGetMeResponse = zMe;

export const zUpdateMeData = z.object({
  body: z.object({
    bannerUrl: z.string().max(2048).nullish(),
    firstName: z.string().min(2).max(255).nullish(),
    lastName: z.string().min(2).max(255).nullish(),
    language: z.enum(['en', 'nl']).optional(),
    newsletter: z.boolean().optional(),
    thumbnailUrl: z.string().max(2048).nullish(),
    slug: z.string().min(2).max(255).optional(),
    userFlags: z
      .object({
        finishedOnboarding: z.boolean().optional(),
      })
      .optional(),
  }),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * User
 */
export const zUpdateMeResponse = zUser;

export const zToggleMfaData = z.object({
  body: z
    .object({
      passkeyData: z
        .object({
          credentialId: z.string(),
          clientDataJSON: z.string(),
          authenticatorObject: z.string(),
          signature: z.string(),
        })
        .optional(),
      totpCode: z
        .string()
        .regex(/^\d{6}$/)
        .optional(),
      mfaRequired: z.boolean(),
    })
    .optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * User
 */
export const zToggleMfaResponse = zUser;

export const zGetMyAuthData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * User sign-up info
 */
export const zGetMyAuthResponse = zMeAuthData;

export const zGetMyInvitationsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Invitations pending
 */
export const zGetMyInvitationsResponse = z.object({
  items: z.array(
    z.object({
      entity: zContextEntityBase,
      inactiveMembership: zInactiveMembership,
    }),
  ),
  total: z.number(),
});

export const zDeleteMySessionsData = z.object({
  body: z
    .object({
      ids: z.array(z.string()).min(1).max(50),
    })
    .optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Success
 */
export const zDeleteMySessionsResponse = z.object({
  data: z.array(z.unknown()),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.record(z.string(), z.array(z.string())).optional(),
});

export const zDeleteMyMembershipData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    entityId: z.string().max(50),
    entityType: z.enum(['organization']),
  }),
});

/**
 * Membership removed
 */
export const zDeleteMyMembershipResponse = z.void();

export const zGetUploadTokenData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    public: z.union([z.string(), z.boolean()]).optional().default('false'),
    organizationId: z.string().optional(),
    templateId: z.enum(['avatar', 'cover', 'attachment']),
  }),
});

/**
 * Upload token with a scope for a user or organization
 */
export const zGetUploadTokenResponse = zUploadToken;

export const zUnsubscribeMeData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.object({
    token: z.string(),
  }),
});

export const zGetMyMembershipsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * User memberships
 */
export const zGetMyMembershipsResponse = z.object({
  items: z.array(zMembershipBase),
});

export const zGetUnseenCountsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Unseen counts per parent context entity per entity type
 */
export const zGetUnseenCountsResponse = z.record(z.string(), z.record(z.string(), z.int().gte(0)));

export const zCheckSlugData = z.object({
  body: z.object({
    slug: z.string(),
    entityType: z.enum(['user', 'organization']),
  }),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Slug is available
 */
export const zCheckSlugResponse = z.void();

export const zGetPublicStreamData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

export const zPostPublicCatchupData = z.object({
  body: z.object({
    cursor: z.string().optional(),
    seqs: z.record(z.string(), z.int()).optional(),
  }),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Catchup summary
 */
export const zPostPublicCatchupResponse = z.object({
  changes: z.record(
    z.string(),
    z.object({
      seq: z.int(),
      deletedIds: z.array(z.string()),
      mSeq: z.int().optional(),
    }),
  ),
  cursor: z.string().nullable(),
});

export const zGetAppStreamData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

export const zPostAppCatchupData = z.object({
  body: z.object({
    cursor: z.string().optional(),
    seqs: z.record(z.string(), z.int()).optional(),
  }),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Catchup summary
 */
export const zPostAppCatchupResponse = z.object({
  changes: z.record(
    z.string(),
    z.object({
      seq: z.int(),
      deletedIds: z.array(z.string()),
      mSeq: z.int().optional(),
    }),
  ),
  cursor: z.string().nullable(),
});

export const zSystemInviteData = z.object({
  body: z.object({
    emails: z.array(z.email()).min(1).max(50),
  }),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Invitations are sent
 */
export const zSystemInviteResponse = z.object({
  data: z.array(z.unknown()),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.record(z.string(), z.array(z.string())).optional(),
  invitesSentCount: z.number(),
});

export const zDeleteUsersData = z.object({
  body: z.object({
    ids: z.array(z.string()).min(1).max(50),
  }),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Success
 */
export const zDeleteUsersResponse = z.object({
  data: z.array(z.unknown()),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.record(z.string(), z.array(z.string())).optional(),
});

export const zUpdateUserData = z.object({
  body: z
    .object({
      bannerUrl: z.string().max(2048).nullish(),
      firstName: z.string().min(2).max(255).nullish(),
      lastName: z.string().min(2).max(255).nullish(),
      language: z.enum(['en', 'nl']).optional(),
      newsletter: z.boolean().optional(),
      thumbnailUrl: z.string().max(2048).nullish(),
      slug: z.string().min(2).max(255).optional(),
    })
    .optional(),
  path: z.object({
    id: z.string().max(50),
  }),
  query: z.never().optional(),
});

/**
 * User
 */
export const zUpdateUserResponse = zUser;

export const zPaddleWebhookData = z.object({
  body: z.unknown().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Paddle webhook received
 */
export const zPaddleWebhookResponse = z.void();

export const zSendNewsletterData = z.object({
  body: z.object({
    organizationIds: z.array(z.string().max(50)),
    roles: z.array(z.enum(['admin', 'member'])).min(1),
    subject: z.string().max(255),
    content: z.string().max(1000000),
  }),
  path: z.never().optional(),
  query: z
    .object({
      toSelf: z.union([z.string(), z.boolean()]).optional().default('false'),
    })
    .optional(),
});

/**
 * Newsletter sent
 */
export const zSendNewsletterResponse = z.void();

export const zGetTenantsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z
    .object({
      q: z.string().optional(),
      status: z.enum(['active', 'suspended', 'archived']).optional(),
      limit: z.string().optional().default('50'),
      offset: z.string().optional().default('0'),
      sort: z.enum(['createdAt', 'name']).optional(),
      order: z.enum(['asc', 'desc']).optional(),
    })
    .optional(),
});

/**
 * Tenants list
 */
export const zGetTenantsResponse = z.object({
  items: z.array(zTenant),
  total: z.number(),
});

export const zCreateTenantData = z.object({
  body: z.object({
    name: z.string().min(1).max(255),
    status: z.enum(['active', 'suspended', 'archived']).optional(),
  }),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Created tenant
 */
export const zCreateTenantResponse = zTenant;

export const zArchiveTenantData = z.object({
  body: z.never().optional(),
  path: z.object({
    tenantId: z.string().max(24),
  }),
  query: z.never().optional(),
});

/**
 * Archived tenant
 */
export const zArchiveTenantResponse = z.object({
  success: z.boolean(),
});

export const zGetTenantByIdData = z.object({
  body: z.never().optional(),
  path: z.object({
    tenantId: z.string().max(24),
  }),
  query: z.never().optional(),
});

/**
 * Tenant
 */
export const zGetTenantByIdResponse = zTenant;

export const zUpdateTenantData = z.object({
  body: z.object({
    name: z.string().min(1).max(255).optional(),
    status: z.enum(['active', 'suspended', 'archived']).optional(),
    restrictions: z
      .object({
        quotas: z.record(z.string(), z.int().gte(0)).optional(),
        rateLimits: z
          .object({
            apiPointsPerHour: z.int().gte(0).optional(),
          })
          .optional(),
      })
      .optional(),
  }),
  path: z.object({
    tenantId: z.string().max(24),
  }),
  query: z.never().optional(),
});

/**
 * Updated tenant
 */
export const zUpdateTenantResponse = zTenant;

export const zDeleteRequestsData = z.object({
  body: z.object({
    ids: z.array(z.string()).min(1).max(50),
  }),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Success
 */
export const zDeleteRequestsResponse = z.object({
  data: z.array(z.unknown()),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.record(z.string(), z.array(z.string())).optional(),
});

export const zGetRequestsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z
    .object({
      q: z.string().max(255).optional(),
      sort: z.enum(['id', 'email', 'type', 'createdAt']).optional(),
      order: z.enum(['asc', 'desc']).optional(),
      offset: z.string().optional(),
      limit: z.string().optional(),
    })
    .optional(),
});

/**
 * Requests
 */
export const zGetRequestsResponse = z.object({
  items: z.array(zRequest),
  total: z.number(),
});

export const zCreateRequestData = z.object({
  body: z.object({
    email: z.email().max(255),
    type: z.enum(['waitlist', 'newsletter', 'contact']),
    message: z.string().max(255).nullable(),
  }),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Requests
 */
export const zCreateRequestResponse = zRequest;

export const zGetMetricsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Metrics
 */
export const zGetMetricsResponse = z.array(
  z.object({
    date: z.string(),
    count: z.number(),
  }),
);

export const zGetRuntimeMetricsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Runtime metrics
 */
export const zGetRuntimeMetricsResponse = z.object({
  process: z.object({
    uptime: z.number(),
    memory: z.object({
      heapUsed: z.number(),
      heapTotal: z.number(),
      external: z.number(),
      rss: z.number(),
    }),
    cpu: z.object({
      user: z.number(),
      system: z.number(),
    }),
  }),
  otel: z.array(
    z.object({
      name: z.string(),
      description: z.string().optional(),
      unit: z.string().optional(),
      type: z.enum(['gauge', 'counter', 'histogram', 'sum']),
      dataPoints: z.array(
        z.object({
          value: z.union([z.number(), z.record(z.string(), z.number())]),
          attributes: z.record(z.string(), z.string()).optional(),
          startTime: z.string().optional(),
          endTime: z.string().optional(),
        }),
      ),
    }),
  ),
});

export const zGetPublicCountsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Public counts
 */
export const zGetPublicCountsResponse = z.object({
  user: z.number(),
  organization: z.number(),
  attachment: z.number(),
  page: z.number(),
});

export const zGetCacheStatsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Cache statistics
 */
export const zGetCacheStatsResponse = z.object({
  cache: z.object({
    hits: z.number(),
    misses: z.number(),
    hitRate: z.number(),
    invalidations: z.number(),
    coalescedRequests: z.number(),
    totalRequests: z.number(),
    uptimeSeconds: z.number(),
    size: z.number(),
    indexSize: z.number().optional(),
    capacity: z.number(),
    utilization: z.number(),
  }),
});

export const zGetSyncMetricsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z.never().optional(),
});

/**
 * Sync metrics
 */
export const zGetSyncMetricsResponse = z.object({
  messagesReceived: z.number(),
  notificationsSent: z.number(),
  activeConnections: z.number(),
  pgNotifyFallbacks: z.number(),
  recentSpanCount: z.number(),
  spansByName: z.record(z.string(), z.number()),
  avgDurationByName: z.record(z.string(), z.number()),
  errorCount: z.number(),
});

export const zDeleteOrganizationsData = z.object({
  body: z.object({
    ids: z.array(z.string()).min(1).max(50),
  }),
  path: z.object({
    tenantId: z.string().max(50),
  }),
  query: z.never().optional(),
});

/**
 * Success
 */
export const zDeleteOrganizationsResponse = z.object({
  data: z.array(z.unknown()),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.record(z.string(), z.array(z.string())).optional(),
});

export const zCreateOrganizationsData = z.object({
  body: z
    .array(
      z.object({
        id: z
          .string()
          .max(50)
          .regex(/^temp-/),
        name: z.string().min(2).max(255),
        slug: z.string().min(2).max(255),
      }),
    )
    .min(1)
    .max(10),
  path: z.object({
    tenantId: z.string().max(50),
  }),
  query: z.never().optional(),
});

/**
 * Organizations were created
 */
export const zCreateOrganizationsResponse = z.object({
  data: z.array(
    zOrganization.and(
      z.object({
        included: z
          .object({
            membership: zMembershipBase,
            counts: z
              .object({
                membership: z.object({
                  admin: z.number(),
                  member: z.number(),
                  pending: z.number(),
                  total: z.number(),
                }),
                entities: z.object({
                  attachment: z.number(),
                  page: z.number(),
                }),
              })
              .optional(),
          })
          .optional(),
      }),
    ),
  ),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.record(z.string(), z.array(z.string())).optional(),
});

export const zGetOrganizationsData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z
    .object({
      q: z.string().max(255).optional(),
      sort: z.enum(['id', 'name', 'createdAt']).optional(),
      order: z.enum(['asc', 'desc']).optional(),
      offset: z.string().optional(),
      limit: z.string().optional(),
      relatableUserId: z.string().max(50).optional(),
      role: z.enum(['admin', 'member']).optional(),
      excludeArchived: z.enum(['true', 'false']).optional(),
      include: z.string().optional(),
    })
    .optional(),
});

/**
 * Organizations
 */
export const zGetOrganizationsResponse = z.object({
  items: z.array(zOrganization),
  total: z.number(),
});

export const zGetOrganizationData = z.object({
  body: z.never().optional(),
  path: z.object({
    tenantId: z.string().max(50),
    id: z.string().max(50),
  }),
  query: z
    .object({
      slug: z.union([z.string(), z.boolean()]).optional().default('false'),
      include: z.string().optional(),
    })
    .optional(),
});

/**
 * Organization
 */
export const zGetOrganizationResponse = zOrganization;

export const zUpdateOrganizationData = z.object({
  body: z
    .object({
      slug: z.string().min(2).max(255).optional(),
      name: z.string().min(2).max(255).optional(),
      shortName: z.string().min(2).max(255).nullish(),
      country: z.string().max(255).nullish(),
      timezone: z.string().max(255).nullish(),
      defaultLanguage: z.enum(['en', 'nl']).optional(),
      languages: z
        .array(z.enum(['en', 'nl']))
        .min(1)
        .optional(),
      notificationEmail: z.string().max(255).nullish(),
      emailDomains: z.array(z.string().min(4).max(255)).optional(),
      color: z.string().max(255).nullish(),
      thumbnailUrl: z.string().max(2048).nullish(),
      logoUrl: z.string().max(2048).nullish(),
      bannerUrl: z.string().max(2048).nullish(),
      websiteUrl: z.string().max(2048).nullish(),
      welcomeText: z.string().max(1000000).nullish(),
      authStrategies: z
        .array(z.enum(['github', 'google', 'microsoft', 'password', 'passkey', 'totp', 'email']))
        .optional(),
      chatSupport: z.boolean().optional(),
    })
    .optional(),
  path: z.object({
    tenantId: z.string().max(50),
    id: z.string().max(50),
  }),
  query: z.never().optional(),
});

/**
 * Organization was updated
 */
export const zUpdateOrganizationResponse = zOrganization;

export const zGetPagesData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z
    .object({
      q: z.string().max(255).optional(),
      sort: z.enum(['name', 'status', 'createdAt']).optional(),
      order: z.enum(['asc', 'desc']).optional(),
      offset: z.string().optional(),
      limit: z.string().optional(),
      modifiedAfter: z.iso.datetime().optional(),
    })
    .optional(),
});

/**
 * Pages
 */
export const zGetPagesResponse = z.object({
  items: z.array(zPage),
  total: z.number(),
});

export const zGetPageData = z.object({
  body: z.never().optional(),
  path: z.object({
    id: z.string(),
  }),
  query: z.never().optional(),
});

/**
 * Page
 */
export const zGetPageResponse = zPage;

export const zDeletePagesData = z.object({
  body: z.object({
    ids: z.array(z.string()).min(1).max(50),
  }),
  path: z.object({
    tenantId: z.string().max(50),
  }),
  query: z.never().optional(),
});

/**
 * Success
 */
export const zDeletePagesResponse = z.object({
  data: z.array(z.unknown()),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.record(z.string(), z.array(z.string())).optional(),
});

export const zCreatePagesData = z.object({
  body: z
    .array(
      z.object({
        name: z.string().max(255).optional(),
        stx: zStxRequestBase,
      }),
    )
    .min(1)
    .max(50),
  path: z.object({
    tenantId: z.string().max(50),
  }),
  query: z.never().optional(),
});

export const zCreatePagesResponse = z.union([
  z.object({
    data: z.array(zPage),
    rejectedItemIds: z.array(z.string()),
    rejectionReasons: z.record(z.string(), z.array(z.string())).optional(),
  }),
  z.object({
    data: z.array(zPage),
    rejectedItemIds: z.array(z.string()),
    rejectionReasons: z.record(z.string(), z.array(z.string())).optional(),
  }),
]);

export const zUpdatePageData = z.object({
  body: z.object({
    key: z.union([
      z.enum(['name']),
      z.enum(['description']),
      z.enum(['keywords']),
      z.enum(['displayOrder']),
      z.enum(['status']),
      z.enum(['parentId']),
    ]),
    data: z.union([z.string(), z.number(), z.boolean(), z.array(z.string())]).nullable(),
    stx: zStxRequestBase,
  }),
  path: z.object({
    tenantId: z.string().max(50),
    id: z.string().max(50),
  }),
  query: z.never().optional(),
});

/**
 * Page updated
 */
export const zUpdatePageResponse = zPage;

export const zGetUsersData = z.object({
  body: z.never().optional(),
  path: z.never().optional(),
  query: z
    .object({
      q: z.string().max(255).optional(),
      sort: z.enum(['id', 'name', 'email', 'role', 'createdAt', 'lastSeenAt']).optional(),
      order: z.enum(['asc', 'desc']).optional(),
      offset: z.string().optional(),
      limit: z.string().optional(),
      role: z.enum(['admin']).optional(),
    })
    .optional(),
});

/**
 * Users
 */
export const zGetUsersResponse = z.object({
  items: z.array(
    zUserBase.and(
      z.object({
        lastSeenAt: z.string().nullable(),
        role: z.enum(['admin']).nullish(),
      }),
    ),
  ),
  total: z.number(),
});

export const zGetUserData = z.object({
  body: z.never().optional(),
  path: z.object({
    relatableUserId: z.string().max(50),
  }),
  query: z
    .object({
      slug: z.union([z.string(), z.boolean()]).optional().default('false'),
    })
    .optional(),
});

/**
 * Base user schema with essential fields for identification and display.
 */
export const zGetUserResponse = zUserBase.and(
  z.object({
    lastSeenAt: z.string().nullable(),
  }),
);

export const zDeleteAttachmentsData = z.object({
  body: z.object({
    ids: z.array(z.string()).min(1).max(50),
    stx: z
      .object({
        mutationId: z.string(),
        sourceId: z.string(),
      })
      .optional(),
  }),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
  }),
  query: z.never().optional(),
});

/**
 * Success
 */
export const zDeleteAttachmentsResponse = z.object({
  data: z.array(z.unknown()),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.record(z.string(), z.array(z.string())).optional(),
});

export const zGetAttachmentsData = z.object({
  body: z.never().optional(),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
  }),
  query: z
    .object({
      q: z.string().max(255).optional(),
      sort: z.enum(['name', 'createdAt', 'contentType']).optional(),
      order: z.enum(['asc', 'desc']).optional(),
      offset: z.string().optional(),
      limit: z.string().optional(),
      modifiedAfter: z.iso.datetime().optional(),
    })
    .optional(),
});

/**
 * Attachments
 */
export const zGetAttachmentsResponse = z.object({
  items: z.array(zAttachment),
  total: z.number(),
});

export const zCreateAttachmentsData = z.object({
  body: z
    .array(
      z.object({
        id: z.string().max(50).optional(),
        name: z.string().max(255).optional(),
        filename: z.string().max(255),
        contentType: z.string().max(255),
        size: z.string().max(255),
        originalKey: z.string().max(2048),
        bucketName: z.string().max(255),
        public: z.boolean().optional(),
        groupId: z.string().max(50).nullish(),
        convertedContentType: z.string().max(255).nullish(),
        convertedKey: z.string().max(2048).nullish(),
        thumbnailKey: z.string().max(2048).nullish(),
        stx: zStxRequestBase,
      }),
    )
    .min(1)
    .max(50),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
  }),
  query: z.never().optional(),
});

export const zCreateAttachmentsResponse = z.union([
  z.object({
    data: z.array(zAttachment),
    rejectedItemIds: z.array(z.string()),
    rejectionReasons: z.record(z.string(), z.array(z.string())).optional(),
  }),
  z.object({
    data: z.array(zAttachment),
    rejectedItemIds: z.array(z.string()),
    rejectionReasons: z.record(z.string(), z.array(z.string())).optional(),
  }),
]);

export const zGetPresignedUrlData = z.object({
  body: z.never().optional(),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
  }),
  query: z.object({
    key: z.string().max(2048),
  }),
});

/**
 * Presigned URL
 */
export const zGetPresignedUrlResponse = z.string();

export const zGetAttachmentData = z.object({
  body: z.never().optional(),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
    id: z.string().max(50),
  }),
  query: z.never().optional(),
});

/**
 * Attachment
 */
export const zGetAttachmentResponse = zAttachment;

export const zUpdateAttachmentData = z.object({
  body: z.object({
    key: z.union([z.enum(['name']), z.enum(['originalKey'])]),
    data: z.string().nullable(),
    stx: zStxRequestBase,
  }),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
    id: z.string().max(50),
  }),
  query: z.never().optional(),
});

/**
 * Attachment was updated
 */
export const zUpdateAttachmentResponse = zAttachment;

export const zGetAttachmentLinkData = z.object({
  body: z.never().optional(),
  path: z.object({
    id: z.string().max(50),
  }),
  query: z.never().optional(),
});

export const zDeleteMembershipsData = z.object({
  body: z.object({
    ids: z.array(z.string()).min(1).max(50),
  }),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
  }),
  query: z.object({
    entityId: z.string().max(50),
    entityType: z.enum(['organization']),
  }),
});

/**
 * Success
 */
export const zDeleteMembershipsResponse = z.object({
  data: z.array(z.unknown()),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.record(z.string(), z.array(z.string())).optional(),
});

export const zMembershipInviteData = z.object({
  body: z.object({
    emails: z.array(z.email().min(4).max(255)).min(1).max(50),
    role: z.enum(['admin', 'member']),
  }),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
  }),
  query: z.object({
    entityId: z.string().max(50),
    entityType: z.enum(['organization']),
  }),
});

/**
 * Created memberships and invite count
 */
export const zMembershipInviteResponse = z.object({
  data: z.array(zMembershipBase),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.record(z.string(), z.array(z.string())).optional(),
  invitesSentCount: z.number(),
});

export const zUpdateMembershipData = z.object({
  body: z
    .object({
      role: z.enum(['admin', 'member']).optional(),
      muted: z.boolean().optional(),
      archived: z.boolean().optional(),
      displayOrder: z.number().optional(),
    })
    .optional(),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
    id: z.string().max(50),
  }),
  query: z.never().optional(),
});

/**
 * Membership updated
 */
export const zUpdateMembershipResponse = zMembership;

export const zHandleMembershipInvitationData = z.object({
  body: z.never().optional(),
  path: z.object({
    id: z.string().max(50),
    acceptOrReject: z.enum(['accept', 'reject']),
  }),
  query: z.never().optional(),
});

/**
 * Invitation was accepted
 */
export const zHandleMembershipInvitationResponse = zContextEntityBase;

export const zGetMembersData = z.object({
  body: z.never().optional(),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
  }),
  query: z.object({
    q: z.string().max(255).optional(),
    sort: z.enum(['id', 'name', 'email', 'role', 'createdAt', 'lastSeenAt']).optional(),
    order: z.enum(['asc', 'desc']).optional(),
    offset: z.string().optional(),
    limit: z.string().optional(),
    entityId: z.string().max(50),
    entityType: z.enum(['organization']),
    role: z.enum(['admin', 'member']).optional(),
    userIds: z.string().optional(),
  }),
});

/**
 * Members
 */
export const zGetMembersResponse = z.object({
  items: z.array(
    zUserBase.and(
      z.object({
        lastSeenAt: z.string().nullable(),
        membership: zMembershipBase,
      }),
    ),
  ),
  total: z.number(),
});

export const zGetPendingMembershipsData = z.object({
  body: z.never().optional(),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
  }),
  query: z.object({
    q: z.string().max(255).optional(),
    sort: z.enum(['createdAt']).optional(),
    order: z.enum(['asc', 'desc']).optional(),
    offset: z.string().optional(),
    limit: z.string().optional(),
    entityId: z.string().max(50),
    entityType: z.enum(['organization']),
  }),
});

/**
 * Pending memberships
 */
export const zGetPendingMembershipsResponse = z.object({
  items: z.array(
    z.object({
      id: z.string(),
      email: z.email(),
      thumbnailUrl: z.string().nullable(),
      role: z.enum(['admin', 'member']).nullable(),
      createdAt: z.string(),
      createdBy: zUserMinimalBase.and(z.record(z.string(), z.unknown())).nullable(),
    }),
  ),
  total: z.number(),
});

export const zMarkSeenData = z.object({
  body: z.object({
    entityIds: z.array(z.string().max(50)).min(1).max(500),
    entityType: z.enum(['attachment', 'page']),
  }),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
  }),
  query: z.never().optional(),
});

/**
 * Seen records processed
 */
export const zMarkSeenResponse = z.object({
  newCount: z.int().gte(0),
});
