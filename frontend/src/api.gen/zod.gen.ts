// This file is auto-generated by @hey-api/openapi-ts

import * as z from 'zod';

/**
 * Base user schema with essential fields for identification and display.
 */
export const zUserBase = z.object({
  id: z.string(),
  name: z.string(),
  description: z.union([z.string(), z.null()]),
  createdAt: z.string(),
  modifiedAt: z.union([z.string(), z.null()]),
  slug: z.string(),
  thumbnailUrl: z.union([z.string(), z.null()]),
  bannerUrl: z.union([z.string(), z.null()]),
  description: z.union([z.string(), z.null()]),
  email: z.email(),
  entityType: z.enum(['user']),
});

/**
 * Base schema for entities with memberships (e.g. organization).
 */
export const zContextEntityBase = z.object({
  id: z.string(),
  name: z.string(),
  createdAt: z.string(),
  modifiedAt: z.union([z.string(), z.null()]),
  tenantId: z.string(),
  entityType: z.enum(['organization']),
  slug: z.string(),
  thumbnailUrl: z.union([z.string(), z.null()]),
  bannerUrl: z.union([z.string(), z.null()]),
});

/**
 * Core membership fields shared across active and inactive memberships.
 */
export const zMembershipBase = z.object({
  id: z.string().max(50),
  tenantId: z.string().max(24),
  contextType: z.enum(['organization']),
  userId: z.string().max(50),
  role: z.enum(['admin', 'member']),
  archived: z.boolean(),
  muted: z.boolean(),
  displayOrder: z.number().gte(-140737488355328).lte(140737488355327),
  organizationId: z.string().max(50),
});

/**
 * Sync transaction metadata stored on entities for offline and realtime support.
 */
export const zStxBase = z.object({
  mutationId: z.string(),
  sourceId: z.string(),
  version: z.int(),
  fieldVersions: z.record(z.string(), z.int()),
});

/**
 * Realtime notification delivered via SSE for entity and membership changes.
 */
export const zStreamNotification = z.object({
  action: z.enum(['create', 'update', 'delete']),
  entityType: z.nullable(z.enum(['attachment', 'page'])),
  resourceType: z.nullable(z.enum(['request', 'membership', 'inactive_membership', 'tenant'])),
  entityId: z.string(),
  organizationId: z.union([z.string(), z.null()]),
  contextType: z.nullable(z.enum(['organization'])),
  seq: z.union([z.int(), z.null()]),
  stx: zStxBase.and(z.union([z.record(z.string(), z.unknown()), z.null()])),
  cacheToken: z.union([z.string(), z.null()]),
});

/**
 * Error info for failed CDC activities (dead letters).
 */
export const zActivityError = z.object({
  lsn: z.string(),
  message: z.string(),
  code: z.optional(z.union([z.string(), z.null()])),
  retryCount: z.number(),
  resolved: z.optional(z.boolean()),
});

/**
 * Standard error response returned by all API endpoints.
 */
export const zApiError = z.object({
  name: z.string(),
  message: z.string(),
  type: z.string(),
  status: z.int().gte(400).lte(599),
  severity: z.enum(['fatal', 'error', 'warn', 'info', 'debug', 'trace']),
  entityType: z.optional(z.enum(['user', 'organization', 'attachment', 'page'])),
  logId: z.optional(z.string()),
  path: z.optional(z.string()),
  method: z.optional(z.string()),
  timestamp: z.optional(z.string()),
  userId: z.optional(z.string()),
  organizationId: z.optional(z.string()),
});

/**
 * Error returned when the request is malformed or contains invalid data.
 */
export const zBadRequestError = zApiError.and(
  z.object({
    status: z.optional(z.literal(400)),
  }),
);

/**
 * Error returned when authentication is missing or invalid.
 */
export const zUnauthorizedError = zApiError.and(
  z.object({
    status: z.optional(z.literal(401)),
  }),
);

/**
 * Error returned when the user lacks permission for the requested action.
 */
export const zForbiddenError = zApiError.and(
  z.object({
    status: z.optional(z.literal(403)),
  }),
);

/**
 * Error returned when the requested resource cannot be found.
 */
export const zNotFoundError = zApiError.and(
  z.object({
    status: z.optional(z.literal(404)),
  }),
);

/**
 * Error returned when rate limits are exceeded.
 */
export const zTooManyRequestsError = zApiError.and(
  z.object({
    status: z.optional(z.literal(429)),
  }),
);

/**
 * An auditable event recording an entity change, used for sync and history.
 */
export const zActivity = z.object({
  id: z.string().max(50),
  tenantId: z.union([z.string().max(24), z.null()]),
  userId: z.union([z.string().max(50), z.null()]),
  entityType: z.nullable(z.enum(['user', 'organization', 'attachment', 'page'])),
  resourceType: z.nullable(z.enum(['request', 'membership', 'inactive_membership', 'tenant'])),
  action: z.enum(['create', 'update', 'delete']),
  tableName: z.string().max(255),
  type: z.string().max(255),
  entityId: z.union([z.string().max(50), z.null()]),
  organizationId: z.union([z.string().max(50), z.null()]),
  createdAt: z.string(),
  changedKeys: z.union([z.array(z.string()), z.null()]),
  stx: z.union([zStxBase, z.null()]),
  seq: z.union([z.int().gte(-2147483648).lte(2147483647), z.null()]),
  error: z.union([zActivityError, z.null()]),
});

/**
 * A user with profile data and last-seen activity timestamp.
 */
export const zUser = z.object({
  createdAt: z.string(),
  id: z.string().max(50),
  entityType: z.enum(['user']),
  name: z.string().max(255),
  description: z.union([z.string(), z.null()]),
  slug: z.string().max(255),
  thumbnailUrl: z.union([z.string().max(2048), z.null()]),
  bannerUrl: z.union([z.string().max(2048), z.null()]),
  email: z.email(),
  mfaRequired: z.boolean(),
  firstName: z.union([z.string().max(255), z.null()]),
  lastName: z.union([z.string().max(255), z.null()]),
  language: z.enum(['en', 'nl']),
  newsletter: z.boolean(),
  userFlags: z.object({
    finishedOnboarding: z.boolean(),
  }),
  modifiedAt: z.union([z.string(), z.null()]),
  lastStartedAt: z.union([z.string(), z.null()]),
  lastSignInAt: z.union([z.string(), z.null()]),
  modifiedBy: z.union([z.string().max(50), z.null()]),
  lastSeenAt: z.union([z.string(), z.null()]),
});

/**
 * The currently authenticated user with their system role.
 */
export const zMe = z.object({
  user: zUser,
  systemRole: z.enum(['admin', 'user']),
});

/**
 * Authentication metadata for the current user session.
 */
export const zMeAuthData = z.object({
  enabledOAuth: z.array(z.enum(['github'])),
  hasTotp: z.boolean(),
  hasPassword: z.boolean(),
  sessions: z.array(
    z.object({
      id: z.string().max(50),
      type: z.enum(['regular', 'impersonation', 'mfa']),
      userId: z.string().max(50),
      deviceName: z.union([z.string().max(255), z.null()]),
      deviceType: z.enum(['desktop', 'mobile']),
      deviceOs: z.union([z.string().max(255), z.null()]),
      browser: z.union([z.string().max(255), z.null()]),
      authStrategy: z.enum(['github', 'google', 'microsoft', 'password', 'passkey', 'totp', 'email']),
      createdAt: z.string(),
      expiresAt: z.string(),
      isCurrent: z.boolean(),
    }),
  ),
  passkeys: z.array(
    z.object({
      id: z.string().max(50),
      userId: z.string().max(50),
      deviceName: z.union([z.string().max(255), z.null()]),
      deviceType: z.enum(['desktop', 'mobile']),
      deviceOs: z.union([z.string().max(255), z.null()]),
      browser: z.union([z.string().max(255), z.null()]),
      nameOnDevice: z.string().max(255),
      createdAt: z.string(),
    }),
  ),
});

/**
 * A membership record for a user who has not yet accepted an invitation.
 */
export const zInactiveMembership = z.object({
  createdAt: z.string(),
  id: z.string().max(50),
  tenantId: z.string().max(24),
  contextType: z.enum(['organization']),
  email: z.string().max(255),
  userId: z.union([z.string().max(50), z.null()]),
  tokenId: z.union([z.string().max(50), z.null()]),
  role: z.enum(['admin', 'member']),
  rejectedAt: z.union([z.string(), z.null()]),
  createdBy: z.string().max(50),
  organizationId: z.string().max(50),
});

/**
 * A signed token authorizing file uploads to the configured storage provider.
 */
export const zUploadToken = z.object({
  public: z.boolean(),
  sub: z.string(),
  s3: z.boolean(),
  signature: z.union([z.string(), z.null()]),
  params: z.union([
    z.object({
      auth: z.object({
        key: z.string(),
        expires: z.optional(z.string()),
      }),
    }),
    z.null(),
  ]),
});

/**
 * A tenant representing an isolated data partition for multi-tenancy.
 */
export const zTenant = z.object({
  id: z.string().max(24),
  name: z.string(),
  status: z.enum(['active', 'suspended', 'archived']),
  createdAt: z.string(),
  modifiedAt: z.union([z.string(), z.null()]),
});

/**
 * A contact or waitlist submission from an unauthenticated user.
 */
export const zRequest = z.object({
  createdAt: z.string(),
  id: z.string().max(50),
  message: z.union([z.string().max(255), z.null()]),
  email: z.string().max(255),
  type: z.enum(['waitlist', 'newsletter', 'contact']),
  wasInvited: z.boolean(),
});

/**
 * An organization with settings, restrictions, and membership context.
 */
export const zOrganization = z.object({
  createdAt: z.string(),
  id: z.string().max(50),
  entityType: z.enum(['organization']),
  tenantId: z.string().max(24),
  name: z.string().max(255),
  modifiedAt: z.union([z.string(), z.null()]),
  slug: z.string().max(255),
  thumbnailUrl: z.union([z.string().max(2048), z.null()]),
  bannerUrl: z.union([z.string().max(2048), z.null()]),
  createdBy: z.union([z.string().max(50), z.null()]),
  modifiedBy: z.union([z.string().max(50), z.null()]),
  shortName: z.union([z.string().max(255), z.null()]),
  country: z.union([z.string().max(255), z.null()]),
  timezone: z.union([z.string().max(255), z.null()]),
  defaultLanguage: z.enum(['en', 'nl']),
  languages: z.array(z.enum(['en', 'nl'])).min(1),
  notificationEmail: z.union([z.string().max(255), z.null()]),
  emailDomains: z.array(z.string()),
  color: z.union([z.string().max(255), z.null()]),
  logoUrl: z.union([z.string().max(2048), z.null()]),
  websiteUrl: z.union([z.string().max(2048), z.null()]),
  welcomeText: z.union([z.string().max(100000), z.null()]),
  authStrategies: z.array(z.enum(['github', 'google', 'microsoft', 'password', 'passkey', 'totp', 'email'])),
  chatSupport: z.boolean(),
  included: z.optional(
    z.object({
      membership: z.optional(zMembershipBase),
      counts: z.optional(
        z.object({
          membership: z.object({
            admin: z.number(),
            member: z.number(),
            pending: z.number(),
            total: z.number(),
          }),
          entities: z.object({
            attachment: z.number(),
            page: z.number(),
          }),
        }),
      ),
    }),
  ),
  can: z.optional(
    z.object({
      create: z.boolean(),
      read: z.boolean(),
      update: z.boolean(),
      delete: z.boolean(),
      search: z.boolean(),
    }),
  ),
});

/**
 * A content page belonging to an organization.
 */
export const zPage = z.object({
  createdAt: z.string(),
  id: z.string().max(50),
  entityType: z.enum(['page']),
  tenantId: z.string().max(24),
  name: z.string().max(255),
  modifiedAt: z.union([z.string(), z.null()]),
  stx: zStxBase,
  description: z.union([z.string(), z.null()]),
  keywords: z.string().max(100000),
  createdBy: z.union([z.string().max(50), z.null()]),
  modifiedBy: z.union([z.string().max(50), z.null()]),
  status: z.enum(['unpublished', 'published', 'archived']),
  publicAccess: z.boolean(),
  parentId: z.union([z.string().max(50), z.null()]),
  displayOrder: z.number().gte(-140737488355328).lte(140737488355327),
});

/**
 * Sync transaction metadata sent with mutations for idempotency and conflict detection.
 */
export const zStxRequestBase = z.object({
  mutationId: z.string().max(32),
  sourceId: z.string().max(64),
  lastReadVersion: z.int().gte(0),
});

/**
 * A file attachment belonging to an organization.
 */
export const zAttachment = z.object({
  createdAt: z.string(),
  id: z.string().max(50),
  entityType: z.enum(['attachment']),
  tenantId: z.string().max(24),
  name: z.string().max(255),
  modifiedAt: z.union([z.string(), z.null()]),
  stx: zStxBase,
  description: z.union([z.string(), z.null()]),
  keywords: z.string().max(100000),
  createdBy: z.union([z.string().max(50), z.null()]),
  modifiedBy: z.union([z.string().max(50), z.null()]),
  public: z.boolean(),
  bucketName: z.string().max(255),
  groupId: z.union([z.string().max(50), z.null()]),
  filename: z.string().max(255),
  contentType: z.string().max(255),
  convertedContentType: z.union([z.string().max(255), z.null()]),
  size: z.string().max(255),
  originalKey: z.string().max(2048),
  convertedKey: z.union([z.string().max(2048), z.null()]),
  thumbnailKey: z.union([z.string().max(2048), z.null()]),
  organizationId: z.string().max(50),
  can: z.optional(
    z.object({
      create: z.boolean(),
      read: z.boolean(),
      update: z.boolean(),
      delete: z.boolean(),
      search: z.boolean(),
    }),
  ),
});

/**
 * A user's membership in a context entity, including role and activity data.
 */
export const zMembership = z.object({
  createdAt: z.string(),
  id: z.string().max(50),
  tenantId: z.string().max(24),
  contextType: z.enum(['organization']),
  userId: z.string().max(50),
  role: z.enum(['admin', 'member']),
  createdBy: z.string().max(50),
  modifiedAt: z.union([z.string(), z.null()]),
  modifiedBy: z.union([z.string().max(50), z.null()]),
  archived: z.boolean(),
  muted: z.boolean(),
  displayOrder: z.number().gte(-140737488355328).lte(140737488355327),
  organizationId: z.string().max(50),
});

export const zGetActivitiesData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      q: z.optional(z.string().max(255)),
      sort: z.optional(z.enum(['createdAt', 'type', 'tableName'])),
      order: z.optional(z.enum(['asc', 'desc'])),
      offset: z.optional(z.string()),
      limit: z.optional(z.string()),
      userId: z.optional(z.union([z.string().max(50), z.null()])),
      entityType: z.optional(z.enum(['user', 'organization', 'attachment', 'page'])),
      resourceType: z.optional(z.enum(['request', 'membership', 'inactive_membership', 'tenant'])),
      action: z.optional(z.enum(['create', 'update', 'delete'])),
      tableName: z.optional(z.string().max(255)),
      type: z.optional(z.string().max(255)),
      entityId: z.optional(z.union([z.string().max(50), z.null()])),
    }),
  ),
});

/**
 * Activities
 */
export const zGetActivitiesResponse = z.object({
  items: z.array(zActivity),
  total: z.number(),
});

export const zGetAuthHealthData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Auth health status
 */
export const zGetAuthHealthResponse = z.object({
  restrictedMode: z.boolean(),
  retryAfter: z.optional(z.number()),
});

export const zGetActivitiesData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      q: z.optional(z.string()),
      sort: z.optional(z.enum(['createdAt', 'type', 'tableName'])),
      order: z.optional(z.enum(['asc', 'desc'])),
      offset: z.optional(z.string()),
      limit: z.optional(z.string()),
      userId: z.optional(z.string()),
      entityType: z.optional(z.enum(['user', 'organization', 'attachment', 'page'])),
      resourceType: z.optional(z.enum(['request', 'membership'])),
      action: z.optional(z.enum(['create', 'update', 'delete'])),
      tableName: z.optional(z.string()),
      type: z.optional(z.string()),
      entityId: z.optional(z.string()),
    }),
  ),
});

/**
 * Activities
 */
export const zGetActivitiesResponse = z.object({
  items: z.array(zActivity),
  total: z.number(),
});

export const zCheckEmailData = z.object({
  body: z.object({
    email: z.email(),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Email exists
 */
export const zCheckEmailResponse = z.void();

export const zInvokeTokenData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    type: z.enum(['email-verification', 'oauth-verification', 'password-reset', 'invitation', 'confirm-mfa']),
    token: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zGetTokenDataData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    type: z.enum(['email-verification', 'oauth-verification', 'password-reset', 'invitation', 'confirm-mfa']),
    id: z.string().max(50),
  }),
  query: z.optional(z.never()),
});

/**
 * Token is valid
 */
export const zGetTokenDataResponse = z.object({
  email: z.email(),
  userId: z.optional(z.string()),
  inactiveMembershipId: z.optional(z.string()),
});

export const zStartImpersonationData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    targetUserId: z.string(),
  }),
});

/**
 * Impersonating
 */
export const zStartImpersonationResponse = z.void();

export const zStopImpersonationData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Stopped impersonating
 */
export const zStopImpersonationResponse = z.void();

export const zResendInvitationWithTokenData = z.object({
  body: z.union([
    z.object({
      email: z.email(),
      tokenId: z.optional(z.string()),
    }),
    z.object({
      email: z.optional(z.email()),
      tokenId: z.string(),
    }),
  ]),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Invitation email sent
 */
export const zResendInvitationWithTokenResponse = z.void();

export const zSignOutData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * User signed out
 */
export const zSignOutResponse = z.void();

export const zGenerateTotpKeyData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Challenge created
 */
export const zGenerateTotpKeyResponse = z.object({
  totpUri: z.string(),
  manualKey: z.string(),
});

export const zDeleteTotpData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * TOTP deleted
 */
export const zDeleteTotpResponse = z.void();

export const zCreateTotpData = z.object({
  body: z.object({
    code: z.string().regex(/^\d{6}$/),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zSignInWithTotpData = z.object({
  body: z.object({
    code: z.string().regex(/^\d{6}$/),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * TOTP verified
 */
export const zSignInWithTotpResponse = z.void();

export const zSignUpData = z.object({
  body: z.optional(
    z.object({
      email: z.email(),
      password: z.string().min(8).max(100),
    }),
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zSignUpWithTokenData = z.object({
  body: z.object({
    email: z.email(),
    password: z.string().min(8).max(100),
  }),
  path: z.object({
    tokenId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * User signed up
 */
export const zSignUpWithTokenResponse = z.object({
  membershipInvite: z.boolean(),
});

export const zRequestPasswordData = z.object({
  body: z.object({
    email: z.email(),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Password reset email sent
 */
export const zRequestPasswordResponse = z.void();

export const zCreatePasswordData = z.object({
  body: z.object({
    password: z.string().min(8).max(100),
  }),
  path: z.object({
    tokenId: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * Password created
 */
export const zCreatePasswordResponse = z.object({
  mfa: z.boolean(),
});

export const zSignInData = z.object({
  body: z.object({
    email: z.email(),
    password: z.string().min(8).max(100),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * User signed in
 */
export const zSignInResponse = z.object({
  emailVerified: z.boolean(),
  mfa: z.optional(z.boolean()),
});

export const zCreatePasskeyData = z.object({
  body: z.object({
    attestationObject: z.string(),
    clientDataJSON: z.string(),
    nameOnDevice: z.string().max(255),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Passkey created
 */
export const zCreatePasskeyResponse = z.object({
  id: z.string().max(50),
  userId: z.string().max(50),
  deviceName: z.union([z.string().max(255), z.null()]),
  deviceType: z.enum(['desktop', 'mobile']),
  deviceOs: z.union([z.string().max(255), z.null()]),
  browser: z.union([z.string().max(255), z.null()]),
  nameOnDevice: z.string().max(255),
  createdAt: z.string(),
});

export const zDeletePasskeyData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().max(50),
  }),
  query: z.optional(z.never()),
});

/**
 * Passkey deleted
 */
export const zDeletePasskeyResponse = z.void();

export const zGeneratePasskeyChallengeData = z.object({
  body: z.object({
    type: z.enum(['authentication', 'mfa', 'registration']),
    email: z.optional(z.string().max(255)),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Challenge generated
 */
export const zGeneratePasskeyChallengeResponse = z.object({
  challengeBase64: z.string(),
  credentialIds: z.array(z.string()),
});

export const zSignInWithPasskeyData = z.object({
  body: z.object({
    credentialId: z.string(),
    clientDataJSON: z.string(),
    authenticatorObject: z.string(),
    signature: z.string(),
    type: z.enum(['authentication', 'mfa']),
    email: z.optional(z.string().max(255)),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Passkey verified
 */
export const zSignInWithPasskeyResponse = z.void();

export const zGithubData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      type: z.optional(z.enum(['auth', 'connect', 'invite', 'verify'])),
      redirectAfter: z.optional(z.string()),
    }),
  ),
});

export const zGoogleData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      type: z.optional(z.enum(['auth', 'connect', 'invite', 'verify'])),
      redirectAfter: z.optional(z.string()),
    }),
  ),
});

export const zMicrosoftData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      type: z.optional(z.enum(['auth', 'connect', 'invite', 'verify'])),
      redirectAfter: z.optional(z.string()),
    }),
  ),
});

export const zGithubCallbackData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    code: z.string(),
    state: z.string(),
    error: z.optional(z.string()),
    error_description: z.optional(z.string()),
    error_uri: z.optional(z.string()),
  }),
});

export const zGoogleCallbackData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    code: z.string(),
    state: z.string(),
  }),
});

export const zMicrosoftCallbackData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    code: z.string(),
    state: z.string(),
  }),
});

export const zDeleteMeData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * User deleted
 */
export const zDeleteMeResponse = z.void();

export const zGetMeData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * User
 */
export const zGetMeResponse = zMe;

export const zUpdateMeData = z.object({
  body: z.object({
    bannerUrl: z.optional(z.union([z.string().max(2048), z.null()])),
    firstName: z.optional(z.union([z.string().min(2).max(255), z.null()])),
    lastName: z.optional(z.union([z.string().min(2).max(255), z.null()])),
    language: z.optional(z.enum(['en', 'nl'])),
    newsletter: z.optional(z.boolean()),
    thumbnailUrl: z.optional(z.union([z.string().max(2048), z.null()])),
    slug: z.optional(z.string().min(2).max(255)),
    userFlags: z.optional(
      z.object({
        finishedOnboarding: z.optional(z.boolean()),
      }),
    ),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * User
 */
export const zUpdateMeResponse = zUser;

export const zToggleMfaData = z.object({
  body: z.optional(
    z.object({
      passkeyData: z.optional(
        z.object({
          credentialId: z.string(),
          clientDataJSON: z.string(),
          authenticatorObject: z.string(),
          signature: z.string(),
        }),
      ),
      totpCode: z.optional(z.string().regex(/^\d{6}$/)),
      mfaRequired: z.boolean(),
    }),
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * User
 */
export const zToggleMfaResponse = zUser;

export const zGetMyAuthData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * User sign-up info
 */
export const zGetMyAuthResponse = zMeAuthData;

export const zGetMyInvitationsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Invitations pending
 */
export const zGetMyInvitationsResponse = z.object({
  items: z.array(
    z.object({
      entity: zContextEntityBase,
      inactiveMembership: zInactiveMembership,
    }),
  ),
  total: z.number(),
});

export const zDeleteMySessionsData = z.object({
  body: z.optional(
    z.object({
      ids: z.array(z.string()).min(1).max(50),
    }),
  ),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Success
 */
export const zDeleteMySessionsResponse = z.object({
  data: z.array(z.unknown()),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.optional(z.record(z.string(), z.array(z.string()))),
});

export const zDeleteMyMembershipData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    entityId: z.string().max(50),
    entityType: z.enum(['organization']),
  }),
});

/**
 * Membership removed
 */
export const zDeleteMyMembershipResponse = z.void();

export const zGetUploadTokenData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    public: z.optional(z.union([z.string(), z.boolean()])).default('false'),
    organizationId: z.optional(z.string()),
    templateId: z.enum(['avatar', 'cover', 'attachment']),
  }),
});

/**
 * Upload token with a scope for a user or organization
 */
export const zGetUploadTokenResponse = zUploadToken;

export const zUnsubscribeMeData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    token: z.string(),
  }),
});

export const zGetMyMembershipsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * User memberships
 */
export const zGetMyMembershipsResponse = z.object({
  items: z.array(zMembershipBase),
});

export const zCheckSlugData = z.object({
  body: z.object({
    slug: z.string(),
    entityType: z.enum(['user', 'organization']),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Slug is available
 */
export const zCheckSlugResponse = z.void();

export const zGetPublicStreamData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      offset: z.optional(z.string()),
      live: z.optional(z.enum(['sse'])),
      seqs: z.optional(z.string()),
    }),
  ),
});

/**
 * Catch-up summary or SSE stream started
 */
export const zGetPublicStreamResponse = z.object({
  changes: z.record(
    z.string(),
    z.object({
      seq: z.int(),
      deletedIds: z.array(z.string()),
      mSeq: z.optional(z.int()),
    }),
  ),
  cursor: z.union([z.string(), z.null()]),
});

export const zGetAppStreamData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      offset: z.optional(z.string()),
      live: z.optional(z.enum(['sse', 'catchup'])),
      seqs: z.optional(z.string()),
    }),
  ),
});

/**
 * SSE stream or catchup summary response
 */
export const zGetAppStreamResponse = z.object({
  changes: z.record(
    z.string(),
    z.object({
      seq: z.int(),
      deletedIds: z.array(z.string()),
      mSeq: z.optional(z.int()),
    }),
  ),
  cursor: z.union([z.string(), z.null()]),
});

export const zSystemInviteData = z.object({
  body: z.object({
    emails: z.array(z.email()).min(1).max(50),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Invitations are sent
 */
export const zSystemInviteResponse = z.object({
  data: z.array(z.unknown()),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.optional(z.record(z.string(), z.array(z.string()))),
  invitesSentCount: z.number(),
});

export const zDeleteUsersData = z.object({
  body: z.object({
    ids: z.array(z.string()).min(1).max(50),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Success
 */
export const zDeleteUsersResponse = z.object({
  data: z.array(z.unknown()),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.optional(z.record(z.string(), z.array(z.string()))),
});

export const zUpdateUserData = z.object({
  body: z.optional(
    z.object({
      bannerUrl: z.optional(z.union([z.string().max(2048), z.null()])),
      firstName: z.optional(z.union([z.string().min(2).max(255), z.null()])),
      lastName: z.optional(z.union([z.string().min(2).max(255), z.null()])),
      language: z.optional(z.enum(['en', 'nl'])),
      newsletter: z.optional(z.boolean()),
      thumbnailUrl: z.optional(z.union([z.string().max(2048), z.null()])),
      slug: z.optional(z.string().min(2).max(255)),
    }),
  ),
  path: z.object({
    id: z.string().max(50),
  }),
  query: z.optional(z.never()),
});

/**
 * User
 */
export const zUpdateUserResponse = zUser;

export const zPaddleWebhookData = z.object({
  body: z.optional(z.unknown()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Paddle webhook received
 */
export const zPaddleWebhookResponse = z.void();

export const zSendNewsletterData = z.object({
  body: z.object({
    organizationIds: z.array(z.string().max(50)),
    roles: z.array(z.enum(['admin', 'member'])).min(1),
    subject: z.string().max(255),
    content: z.string().max(100000),
  }),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      toSelf: z.optional(z.union([z.string(), z.boolean()])).default('false'),
    }),
  ),
});

/**
 * Newsletter sent
 */
export const zSendNewsletterResponse = z.void();

export const zGetTenantsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      q: z.optional(z.string()),
      status: z.optional(z.enum(['active', 'suspended', 'archived'])),
      limit: z.optional(z.string()).default('50'),
      offset: z.optional(z.string()).default('0'),
      sort: z.optional(z.enum(['createdAt', 'name'])),
      order: z.optional(z.enum(['asc', 'desc'])),
    }),
  ),
});

/**
 * Tenants list
 */
export const zGetTenantsResponse = z.object({
  items: z.array(zTenant),
  total: z.number(),
});

export const zCreateTenantData = z.object({
  body: z.object({
    name: z.string().min(1).max(255),
    status: z.optional(z.enum(['active', 'suspended', 'archived'])),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Created tenant
 */
export const zCreateTenantResponse = zTenant;

export const zArchiveTenantData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: z.string().max(24),
  }),
  query: z.optional(z.never()),
});

/**
 * Archived tenant
 */
export const zArchiveTenantResponse = z.object({
  success: z.boolean(),
});

export const zGetTenantByIdData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: z.string().max(24),
  }),
  query: z.optional(z.never()),
});

/**
 * Tenant
 */
export const zGetTenantByIdResponse = zTenant;

export const zUpdateTenantData = z.object({
  body: z.object({
    name: z.optional(z.string().min(1).max(255)),
    status: z.optional(z.enum(['active', 'suspended', 'archived'])),
  }),
  path: z.object({
    tenantId: z.string().max(24),
  }),
  query: z.optional(z.never()),
});

/**
 * Updated tenant
 */
export const zUpdateTenantResponse = zTenant;

export const zDeleteRequestsData = z.object({
  body: z.object({
    ids: z.array(z.string()).min(1).max(50),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Success
 */
export const zDeleteRequestsResponse = z.object({
  data: z.array(z.unknown()),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.optional(z.record(z.string(), z.array(z.string()))),
});

export const zGetRequestsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      q: z.optional(z.string().max(255)),
      sort: z.optional(z.enum(['id', 'email', 'type', 'createdAt'])),
      order: z.optional(z.enum(['asc', 'desc'])),
      offset: z.optional(z.string()),
      limit: z.optional(z.string()),
    }),
  ),
});

/**
 * Requests
 */
export const zGetRequestsResponse = z.object({
  items: z.array(zRequest),
  total: z.number(),
});

export const zCreateRequestData = z.object({
  body: z.object({
    email: z.email().max(255),
    type: z.enum(['waitlist', 'newsletter', 'contact']),
    message: z.union([z.string().max(255), z.null()]),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Requests
 */
export const zCreateRequestResponse = zRequest;

export const zGetMetricsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Metrics
 */
export const zGetMetricsResponse = z.array(
  z.object({
    date: z.string(),
    count: z.number(),
  }),
);

export const zGetRuntimeMetricsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Runtime metrics
 */
export const zGetRuntimeMetricsResponse = z.object({
  process: z.object({
    uptime: z.number(),
    memory: z.object({
      heapUsed: z.number(),
      heapTotal: z.number(),
      external: z.number(),
      rss: z.number(),
    }),
    cpu: z.object({
      user: z.number(),
      system: z.number(),
    }),
  }),
  otel: z.array(
    z.object({
      name: z.string(),
      description: z.optional(z.string()),
      unit: z.optional(z.string()),
      type: z.enum(['gauge', 'counter', 'histogram', 'sum']),
      dataPoints: z.array(
        z.object({
          value: z.union([z.number(), z.record(z.string(), z.number())]),
          attributes: z.optional(z.record(z.string(), z.string())),
          startTime: z.optional(z.string()),
          endTime: z.optional(z.string()),
        }),
      ),
    }),
  ),
});

export const zGetPublicCountsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Public counts
 */
export const zGetPublicCountsResponse = z.object({
  user: z.number(),
  organization: z.number(),
  attachment: z.number(),
  page: z.number(),
});

export const zGetCacheStatsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Cache statistics
 */
export const zGetCacheStatsResponse = z.object({
  cache: z.object({
    hits: z.number(),
    misses: z.number(),
    hitRate: z.number(),
    invalidations: z.number(),
    coalescedRequests: z.number(),
    totalRequests: z.number(),
    uptimeSeconds: z.number(),
    size: z.number(),
    indexSize: z.optional(z.number()),
    capacity: z.number(),
    utilization: z.number(),
  }),
});

export const zGetSyncMetricsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Sync metrics
 */
export const zGetSyncMetricsResponse = z.object({
  messagesReceived: z.number(),
  notificationsSent: z.number(),
  activeConnections: z.number(),
  pgNotifyFallbacks: z.number(),
  recentSpanCount: z.number(),
  spansByName: z.record(z.string(), z.number()),
  avgDurationByName: z.record(z.string(), z.number()),
  errorCount: z.number(),
});

export const zDeleteOrganizationsData = z.object({
  body: z.object({
    ids: z.array(z.string()).min(1).max(50),
  }),
  path: z.object({
    tenantId: z.string().max(50),
  }),
  query: z.optional(z.never()),
});

/**
 * Success
 */
export const zDeleteOrganizationsResponse = z.object({
  data: z.array(z.unknown()),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.optional(z.record(z.string(), z.array(z.string()))),
});

export const zCreateOrganizationsData = z.object({
  body: z
    .array(
      z.object({
        id: z
          .string()
          .max(50)
          .regex(/^temp-/),
        name: z.string().min(2).max(255),
        slug: z.string().min(2).max(255),
      }),
    )
    .min(1)
    .max(10),
  path: z.object({
    tenantId: z.string().max(50),
  }),
  query: z.optional(z.never()),
});

/**
 * Organizations were created
 */
export const zCreateOrganizationsResponse = z.object({
  data: z.array(
    zOrganization.and(
      z.object({
        included: z.object({
          membership: zMembershipBase,
          counts: z.optional(
            z.object({
              membership: z.object({
                admin: z.number(),
                member: z.number(),
                pending: z.number(),
                total: z.number(),
              }),
              entities: z.object({
                attachment: z.number(),
                page: z.number(),
              }),
            }),
          ),
        }),
      }),
    ),
  ),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.optional(z.record(z.string(), z.array(z.string()))),
});

export const zGetOrganizationsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      q: z.optional(z.string().max(255)),
      sort: z.optional(z.enum(['id', 'name', 'createdAt'])),
      order: z.optional(z.enum(['asc', 'desc'])),
      offset: z.optional(z.string()),
      limit: z.optional(z.string()),
      userId: z.optional(z.string().max(50)),
      role: z.optional(z.enum(['admin', 'member'])),
      excludeArchived: z.optional(z.enum(['true', 'false'])),
      include: z.optional(z.string()),
    }),
  ),
});

/**
 * Organizations
 */
export const zGetOrganizationsResponse = z.object({
  items: z.array(zOrganization),
  total: z.number(),
});

export const zGetOrganizationData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: z.string().max(50),
    organizationId: z.string().max(50),
  }),
  query: z.optional(
    z.object({
      slug: z.optional(z.union([z.string(), z.boolean()])).default('false'),
    }),
  ),
});

/**
 * Organization
 */
export const zGetOrganizationResponse = zOrganization;

export const zUpdateOrganizationData = z.object({
  body: z.optional(
    z.object({
      slug: z.optional(z.string().min(2).max(255)),
      name: z.optional(z.string().min(2).max(255)),
      shortName: z.optional(z.union([z.string().min(2).max(255), z.null()])),
      country: z.optional(z.union([z.string().max(255), z.null()])),
      timezone: z.optional(z.union([z.string().max(255), z.null()])),
      defaultLanguage: z.optional(z.enum(['en', 'nl'])),
      languages: z.optional(z.array(z.enum(['en', 'nl'])).min(1)),
      notificationEmail: z.optional(z.union([z.string().max(255), z.null()])),
      emailDomains: z.optional(z.array(z.string().min(4).max(255))),
      color: z.optional(z.union([z.string().max(255), z.null()])),
      thumbnailUrl: z.optional(z.union([z.string().max(2048), z.null()])),
      logoUrl: z.optional(z.union([z.string().max(2048), z.null()])),
      bannerUrl: z.optional(z.union([z.string().max(2048), z.null()])),
      websiteUrl: z.optional(z.union([z.string().max(2048), z.null()])),
      welcomeText: z.optional(z.union([z.string().max(100000), z.null()])),
      authStrategies: z.optional(
        z.array(z.enum(['github', 'google', 'microsoft', 'password', 'passkey', 'totp', 'email'])),
      ),
      chatSupport: z.optional(z.boolean()),
    }),
  ),
  path: z.object({
    tenantId: z.string().max(50),
    id: z.string().max(50),
  }),
  query: z.optional(z.never()),
});

/**
 * Organization was updated
 */
export const zUpdateOrganizationResponse = zOrganization;

export const zGetPagesData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      q: z.optional(z.string().max(255)),
      sort: z.optional(z.enum(['name', 'status', 'createdAt'])),
      order: z.optional(z.enum(['asc', 'desc'])),
      offset: z.optional(z.string()),
      limit: z.optional(z.string()),
      modifiedAfter: z.optional(z.iso.datetime()),
    }),
  ),
});

/**
 * Pages
 */
export const zGetPagesResponse = z.object({
  items: z.array(zPage),
  total: z.number(),
});

export const zGetPageData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * Page
 */
export const zGetPageResponse = zPage;

export const zDeletePagesData = z.object({
  body: z.object({
    ids: z.array(z.string()).min(1).max(50),
  }),
  path: z.object({
    tenantId: z.string().max(50),
  }),
  query: z.optional(z.never()),
});

/**
 * Success
 */
export const zDeletePagesResponse = z.object({
  data: z.array(z.unknown()),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.optional(z.record(z.string(), z.array(z.string()))),
});

export const zCreatePagesData = z.object({
  body: z
    .array(
      z.object({
        name: z.optional(z.string().max(255)),
        stx: zStxRequestBase,
      }),
    )
    .min(1)
    .max(50),
  path: z.object({
    tenantId: z.string().max(50),
  }),
  query: z.optional(z.never()),
});

export const zCreatePagesResponse = z.union([
  z.object({
    data: z.array(zPage),
    rejectedItemIds: z.array(z.string()),
    rejectionReasons: z.optional(z.record(z.string(), z.array(z.string()))),
  }),
  z.object({
    data: z.array(zPage),
    rejectedItemIds: z.array(z.string()),
    rejectionReasons: z.optional(z.record(z.string(), z.array(z.string()))),
  }),
]);

export const zUpdatePageData = z.object({
  body: z.object({
    name: z.optional(z.string().max(255)),
    description: z.optional(z.union([z.string().max(100000), z.null()])),
    keywords: z.optional(z.string().max(100000)),
    displayOrder: z.optional(z.number().gte(-140737488355328).lte(140737488355327)),
    status: z.optional(z.enum(['unpublished', 'published', 'archived'])),
    parentId: z.optional(z.union([z.string().max(50), z.null()])),
    stx: zStxRequestBase,
  }),
  path: z.object({
    tenantId: z.string().max(50),
    id: z.string().max(50),
  }),
  query: z.optional(z.never()),
});

/**
 * Page updated
 */
export const zUpdatePageResponse = zPage;

export const zGetUsersData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      q: z.optional(z.string().max(255)),
      sort: z.optional(z.enum(['id', 'name', 'email', 'role', 'createdAt', 'lastSeenAt'])),
      order: z.optional(z.enum(['asc', 'desc'])),
      offset: z.optional(z.string()),
      limit: z.optional(z.string()),
      role: z.optional(z.enum(['admin'])),
    }),
  ),
});

/**
 * Users
 */
export const zGetUsersResponse = z.object({
  items: z.array(
    zUser.and(
      z.object({
        role: z.optional(z.nullable(z.enum(['admin']))),
      }),
    ),
  ),
  total: z.number(),
});

export const zGetUserData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    userId: z.string().max(50),
  }),
  query: z.optional(
    z.object({
      slug: z.optional(z.union([z.string(), z.boolean()])).default('false'),
    }),
  ),
});

/**
 * User
 */
export const zGetUserResponse = zUser;

export const zDeleteAttachmentsData = z.object({
  body: z.object({
    ids: z.array(z.string()).min(1).max(50),
    stx: z.optional(
      z.object({
        mutationId: z.string(),
        sourceId: z.string(),
      }),
    ),
  }),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
  }),
  query: z.optional(z.never()),
});

/**
 * Success
 */
export const zDeleteAttachmentsResponse = z.object({
  data: z.array(z.unknown()),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.optional(z.record(z.string(), z.array(z.string()))),
});

export const zGetAttachmentsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
  }),
  query: z.optional(
    z.object({
      q: z.optional(z.string().max(255)),
      sort: z.optional(z.enum(['name', 'createdAt', 'contentType'])),
      order: z.optional(z.enum(['asc', 'desc'])),
      offset: z.optional(z.string()),
      limit: z.optional(z.string()),
      modifiedAfter: z.optional(z.iso.datetime()),
    }),
  ),
});

/**
 * Attachments
 */
export const zGetAttachmentsResponse = z.object({
  items: z.array(zAttachment),
  total: z.number(),
});

export const zCreateAttachmentsData = z.object({
  body: z
    .array(
      z.object({
        id: z.optional(z.string().max(50)),
        name: z.optional(z.string().max(255)),
        filename: z.string().max(255),
        contentType: z.string().max(255),
        size: z.string().max(255),
        organizationId: z.string().max(50),
        createdBy: z.optional(z.union([z.string().max(50), z.null()])),
        originalKey: z.string().max(2048),
        bucketName: z.string().max(255),
        public: z.optional(z.boolean()),
        groupId: z.optional(z.union([z.string().max(50), z.null()])),
        convertedContentType: z.optional(z.union([z.string().max(255), z.null()])),
        convertedKey: z.optional(z.union([z.string().max(2048), z.null()])),
        thumbnailKey: z.optional(z.union([z.string().max(2048), z.null()])),
        stx: zStxRequestBase,
      }),
    )
    .min(1)
    .max(50),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
  }),
  query: z.optional(z.never()),
});

export const zCreateAttachmentsResponse = z.union([
  z.object({
    data: z.array(zAttachment),
    rejectedItemIds: z.array(z.string()),
    rejectionReasons: z.optional(z.record(z.string(), z.array(z.string()))),
  }),
  z.object({
    data: z.array(zAttachment),
    rejectedItemIds: z.array(z.string()),
    rejectionReasons: z.optional(z.record(z.string(), z.array(z.string()))),
  }),
]);

export const zGetPresignedUrlData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
  }),
  query: z.object({
    key: z.string().max(2048),
  }),
});

/**
 * Presigned URL
 */
export const zGetPresignedUrlResponse = z.string();

export const zGetAttachmentData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
    id: z.string().max(50),
  }),
  query: z.optional(z.never()),
});

/**
 * Attachment
 */
export const zGetAttachmentResponse = zAttachment;

export const zUpdateAttachmentData = z.object({
  body: z.object({
    name: z.optional(z.string().max(255)),
    originalKey: z.optional(z.string().max(2048)),
    stx: zStxRequestBase,
  }),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
    id: z.string().max(50),
  }),
  query: z.optional(z.never()),
});

/**
 * Attachment was updated
 */
export const zUpdateAttachmentResponse = zAttachment;

export const zRedirectToAttachmentData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().max(50),
  }),
  query: z.optional(z.never()),
});

export const zDeleteMembershipsData = z.object({
  body: z.object({
    ids: z.array(z.string()).min(1).max(50),
  }),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
  }),
  query: z.object({
    entityId: z.string().max(50),
    entityType: z.enum(['organization']),
  }),
});

/**
 * Success
 */
export const zDeleteMembershipsResponse = z.object({
  data: z.array(z.unknown()),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.optional(z.record(z.string(), z.array(z.string()))),
});

export const zMembershipInviteData = z.object({
  body: z.object({
    emails: z.array(z.email().min(4).max(255)).min(1).max(50),
    role: z.enum(['admin', 'member']),
  }),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
  }),
  query: z.object({
    entityId: z.string().max(50),
    entityType: z.enum(['organization']),
  }),
});

/**
 * Created memberships and invite count
 */
export const zMembershipInviteResponse = z.object({
  data: z.array(zMembershipBase),
  rejectedItemIds: z.array(z.string()),
  rejectionReasons: z.optional(z.record(z.string(), z.array(z.string()))),
  invitesSentCount: z.number(),
});

export const zUpdateMembershipData = z.object({
  body: z.optional(
    z.object({
      role: z.optional(z.enum(['admin', 'member'])),
      muted: z.optional(z.boolean()),
      archived: z.optional(z.boolean()),
      displayOrder: z.optional(z.number()),
    }),
  ),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
    id: z.string().max(50),
  }),
  query: z.optional(z.never()),
});

/**
 * Membership updated
 */
export const zUpdateMembershipResponse = zMembership;

export const zHandleMembershipInvitationData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().max(50),
    acceptOrReject: z.enum(['accept', 'reject']),
  }),
  query: z.optional(z.never()),
});

/**
 * Invitation was accepted
 */
export const zHandleMembershipInvitationResponse = zContextEntityBase;

export const zGetMembersData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
  }),
  query: z.object({
    q: z.optional(z.string().max(255)),
    sort: z.optional(z.enum(['id', 'name', 'email', 'role', 'createdAt', 'lastSeenAt'])),
    order: z.optional(z.enum(['asc', 'desc'])),
    offset: z.optional(z.string()),
    limit: z.optional(z.string()),
    entityId: z.string().max(50),
    entityType: z.enum(['organization']),
    role: z.optional(z.enum(['admin', 'member'])),
  }),
});

/**
 * Members
 */
export const zGetMembersResponse = z.object({
  items: z.array(
    z.object({
      createdAt: z.string(),
      id: z.string().max(50),
      entityType: z.enum(['user']),
      name: z.string().max(255),
      description: z.union([z.string(), z.null()]),
      slug: z.string().max(255),
      thumbnailUrl: z.union([z.string().max(2048), z.null()]),
      bannerUrl: z.union([z.string().max(2048), z.null()]),
      email: z.email(),
      mfaRequired: z.boolean(),
      firstName: z.union([z.string().max(255), z.null()]),
      lastName: z.union([z.string().max(255), z.null()]),
      language: z.enum(['en', 'nl']),
      modifiedAt: z.union([z.string(), z.null()]),
      lastStartedAt: z.union([z.string(), z.null()]),
      lastSignInAt: z.union([z.string(), z.null()]),
      modifiedBy: z.union([z.string().max(50), z.null()]),
      lastSeenAt: z.union([z.string(), z.null()]),
      membership: zMembershipBase,
    }),
  ),
  total: z.number(),
});

export const zGetPendingMembershipsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    tenantId: z.string().max(50),
    orgId: z.string().max(50),
  }),
  query: z.object({
    q: z.optional(z.string().max(255)),
    sort: z.optional(z.enum(['createdAt'])),
    order: z.optional(z.enum(['asc', 'desc'])),
    offset: z.optional(z.string()),
    limit: z.optional(z.string()),
    entityId: z.string().max(50),
    entityType: z.enum(['organization']),
  }),
});

/**
 * Pending memberships
 */
export const zGetPendingMembershipsResponse = z.object({
  items: z.array(
    z.object({
      id: z.string(),
      email: z.email(),
      thumbnailUrl: z.union([z.string(), z.null()]),
      role: z.nullable(z.enum(['admin', 'member'])),
      createdAt: z.string(),
      createdBy: z.union([z.string().max(50), z.null()]),
    }),
  ),
  total: z.number(),
});
