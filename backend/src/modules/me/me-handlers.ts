import { OpenAPIHono } from '@hono/zod-openapi';
import { and, eq, inArray, isNull, sql } from 'drizzle-orm';
import type { EnabledOAuthProvider } from 'shared';
import { appConfig } from 'shared';
import { unsafeInternalDb as db } from '#/db/db';
import { inactiveMembershipsTable } from '#/db/schema/inactive-memberships';
import { membershipsTable } from '#/db/schema/memberships';
import { AuthStrategy, sessionsTable } from '#/db/schema/sessions';
import { unsubscribeTokensTable } from '#/db/schema/unsubscribe-tokens';
import { usersTable } from '#/db/schema/users';
import { env } from '#/env';
import { type Env } from '#/lib/context';
import { AppError } from '#/lib/error';
import { resolveEntity } from '#/lib/resolve-entity';
import { getParams, getSignature } from '#/lib/transloadit';
import { deleteAuthCookie } from '#/modules/auth/general/helpers/cookie';
import { getParsedSessionCookie, setUserSession, validateSession } from '#/modules/auth/general/helpers/session';
import { validatePasskey } from '#/modules/auth/passkeys/helpers/passkey';
import { validateTOTP } from '#/modules/auth/totps/helpers/totps';
import { checkSlugAvailable } from '#/modules/entities/helpers/check-slug';
import { makeContextEntityBaseSelect } from '#/modules/entities/helpers/select';
import { getAuthInfo, getUserSessions } from '#/modules/me/helpers/get-user-info';
import meRoutes from '#/modules/me/me-routes';
import { userSelect } from '#/modules/user/helpers/select';
import { entityTables } from '#/table-config';
import { defaultHook } from '#/utils/default-hook';
import { getIsoDate } from '#/utils/iso-date';
import { logEvent } from '#/utils/logger';
import { verifyUnsubscribeToken } from '#/utils/unsubscribe-token';

// Cast helpers for dynamic context-entity ID columns generated by generateContextEntityIdColumns()
type EntityIdColumnNames = keyof (typeof membershipsTable)['_']['columns'];
type InactiveEntityIdColumnNames = keyof (typeof inactiveMembershipsTable)['_']['columns'];

const app = new OpenAPIHono<Env>({ defaultHook });

// ============================================
// Route handlers
// ============================================

const meRouteHandlers = app
  /**
   * Get me
   */
  .openapi(meRoutes.getMe, async (ctx) => {
    const user = ctx.var.user;
    const systemRole = ctx.var.userSystemRole ?? ('user' as const);

    // Update last visit date
    await db.update(usersTable).set({ lastStartedAt: getIsoDate() }).where(eq(usersTable.id, user.id));

    // Re-select with userSelect to include lastSeenAt (subquery from last_seen table)
    const [userWithActivity] = await db.select(userSelect).from(usersTable).where(eq(usersTable.id, user.id)).limit(1);

    return ctx.json({ user: userWithActivity, systemRole }, 200);
  })
  /**
   * Toggle MFA require for me auth
   */
  .openapi(meRoutes.toggleMfa, async (ctx) => {
    const { mfaRequired, passkeyData, totpCode } = ctx.req.valid('json');
    const user = ctx.var.user;

    // Determine which MFA strategy user is using
    const strategy: Extract<AuthStrategy, 'passkey' | 'totp'> = passkeyData ? 'passkey' : 'totp';

    try {
      // --- Passkey verification ---
      if (passkeyData) await validatePasskey(ctx, { ...passkeyData, userId: user.id });

      // --- TOTP verification ---
      if (totpCode) await validateTOTP({ code: totpCode, userId: user.id });
    } catch (error) {
      if (error instanceof AppError) throw error;

      // Wrap unexpected errors in AppError for consistent error handling
      throw new AppError(500, 'invalid_credentials', 'error', {
        ...(error instanceof Error ? { originalError: error } : {}),
      });
    }

    const [updatedUser] = await db
      .update(usersTable)
      .set({ mfaRequired })
      .where(eq(usersTable.id, user.id))
      .returning();

    if (updatedUser.mfaRequired) {
      // Invalidate all existing regular sessions
      await db
        .delete(sessionsTable)
        .where(and(eq(sessionsTable.userId, updatedUser.id), eq(sessionsTable.type, 'regular')));

      // Clear session cookie to enforce fresh login
      deleteAuthCookie(ctx, 'session');

      // Establish a new session after MFA verification
      await setUserSession(ctx, user, strategy, 'mfa');
    }

    // Re-select with userSelect to include lastSeenAt (subquery from last_seen table)
    const [userWithActivity] = await db.select(userSelect).from(usersTable).where(eq(usersTable.id, user.id)).limit(1);

    return ctx.json(userWithActivity, 200);
  })
  /**
   * Get my auth data
   */
  .openapi(meRoutes.getMyAuth, async (ctx) => {
    const user = ctx.var.user;
    const db = ctx.var.db;

    // Get auth info + sessions in parallel
    const [authInfo, sessions] = await Promise.all([getAuthInfo(db, user.id), getUserSessions(ctx, user.id)]);

    const { oauth, ...restInfo } = authInfo;
    // Filter only providers that are enabled in appConfig
    const enabledOAuth = oauth
      .map(({ provider }) => provider)
      .filter((provider): provider is EnabledOAuthProvider =>
        appConfig.enabledOAuthProviders.includes(provider as EnabledOAuthProvider),
      );

    return ctx.json({ ...restInfo, enabledOAuth, sessions }, 200);
  })
  /**
   * Get my invitations - a list with a combination of pending membership and entity data
   */
  .openapi(meRoutes.getMyInvitations, async (ctx) => {
    const user = ctx.var.user;

    const pendingInvites = await Promise.all(
      appConfig.contextEntityTypes.map((entityType) => {
        const entityTable = entityTables[entityType];
        const entityIdColumnKey = appConfig.entityIdColumnKeys[entityType];

        const contextEntityBaseSelect = makeContextEntityBaseSelect(entityType);

        return db
          .select({
            entity: contextEntityBaseSelect,
            inactiveMembership: inactiveMembershipsTable,
          })
          .from(inactiveMembershipsTable)
          .leftJoin(usersTable, eq(usersTable.id, inactiveMembershipsTable.createdBy))
          .innerJoin(
            entityTable,
            eq(entityTable.id, inactiveMembershipsTable[entityIdColumnKey as InactiveEntityIdColumnNames]),
          )
          .where(
            and(
              eq(inactiveMembershipsTable.contextType, entityType),
              eq(inactiveMembershipsTable.userId, user.id),
              isNull(inactiveMembershipsTable.rejectedAt),
            ),
          );
      }),
    );

    const items = pendingInvites.flat();
    const total = items.length;

    return ctx.json({ items, total }, 200);
  })
  /**
   * Terminate one or more of my sessions
   */
  .openapi(meRoutes.deleteMySessions, async (ctx) => {
    const { ids } = ctx.req.valid('json');
    const user = ctx.var.user;

    const sessionIds = Array.isArray(ids) ? ids : [ids];
    const { sessionToken } = await getParsedSessionCookie(ctx);
    const { session: currentSession } = await validateSession(sessionToken);

    try {
      // Clear auth cookie if user deletes their current session
      if (currentSession && sessionIds.includes(currentSession.id)) deleteAuthCookie(ctx, 'session');

      const deleted = await db
        .delete(sessionsTable)
        .where(and(inArray(sessionsTable.id, sessionIds), eq(sessionsTable.userId, user.id)))
        .returning({ id: sessionsTable.id });

      const deletedIds = deleted.map((s) => s.id);
      const rejectedItemIds = sessionIds.filter((id) => !deletedIds.includes(id));

      return ctx.json({ data: [] as never[], rejectedItemIds }, 200);
    } catch {
      return ctx.json({ data: [] as never[], rejectedItemIds: sessionIds }, 200);
    }
  })
  /**
   * Update current user (me)
   */
  .openapi(meRoutes.updateMe, async (ctx) => {
    const user = ctx.var.user;

    if (!user) throw new AppError(404, 'not_found', 'warn', { entityType: 'user', meta: { user: 'self' } });

    const { userFlags, ...passedUpdates } = ctx.req.valid('json');

    const { slug, firstName, lastName } = passedUpdates;

    if (slug && slug !== user.slug) {
      const slugAvailable = await checkSlugAvailable(slug, db);
      if (!slugAvailable) throw new AppError(409, 'slug_exists', 'warn', { entityType: 'user', meta: { slug } });
    }
    // if userFlags is provided, merge it
    const updateData = {
      ...passedUpdates,
      ...(userFlags && {
        userFlags: sql`${usersTable.userFlags} || ${JSON.stringify(userFlags)}::jsonb`,
      }),
      ...((firstName || lastName) && { name: [firstName, lastName].filter(Boolean).join(' ') }),
      modifiedAt: getIsoDate(),
      modifiedBy: user.id,
    };

    await db.update(usersTable).set(updateData).where(eq(usersTable.id, user.id));

    // Re-select with userSelect to include lastSeenAt (subquery from last_seen table)
    const [userWithActivity] = await db.select(userSelect).from(usersTable).where(eq(usersTable.id, user.id)).limit(1);

    return ctx.json(userWithActivity, 200);
  })
  /**
   * Delete current user (me)
   */
  .openapi(meRoutes.deleteMe, async (ctx) => {
    const user = ctx.var.user;

    // Check if user exists
    if (!user) throw new AppError(404, 'not_found', 'warn', { entityType: 'user', meta: { user: 'self' } });

    // Delete user
    await db.delete(usersTable).where(eq(usersTable.id, user.id));

    deleteAuthCookie(ctx, 'session');
    logEvent('info', 'User deleted itself', { userId: user.id });

    return ctx.body(null, 204);
  })
  /**
   * Delete one of my entity memberships
   */
  .openapi(meRoutes.deleteMyMembership, async (ctx) => {
    const user = ctx.var.user;

    const { entityType, entityId } = ctx.req.valid('query');

    const entity = await resolveEntity(entityType, entityId, db);
    if (!entity) throw new AppError(404, 'not_found', 'warn', { entityType });

    const entityIdColumnKey = appConfig.entityIdColumnKeys[entityType];

    // Delete memberships
    await db
      .delete(membershipsTable)
      .where(
        and(
          eq(membershipsTable.userId, user.id),
          eq(membershipsTable[entityIdColumnKey as EntityIdColumnNames], entity.id),
        ),
      );

    logEvent('info', 'User left entity', { userId: user.id });

    return ctx.body(null, 204);
  })
  /**
   * Get upload token
   */
  .openapi(meRoutes.getUploadToken, async (ctx) => {
    const { public: isPublic, organizationId, templateId } = ctx.req.valid('query');
    const user = ctx.var.user;

    // This will be used to as first part of S3 key
    const sub = [appConfig.s3.bucketPrefix, organizationId, user.id]
      .filter((part): part is string => typeof part === 'string')
      .join('/');

    // If Transloadit not configured, return response indicating local-only mode
    if (!env.TRANSLOADIT_KEY || !env.TRANSLOADIT_SECRET) {
      return ctx.json({ sub, public: isPublic, s3: !!env.S3_ACCESS_KEY_ID, params: null, signature: null }, 200);
    }

    try {
      const params = getParams(templateId, isPublic, sub);
      const paramsString = JSON.stringify(params);
      const signature = getSignature(paramsString);

      const token = { sub, public: isPublic, s3: !!env.S3_ACCESS_KEY_ID, params, signature };

      return ctx.json(token, 200);
    } catch (error) {
      if (error instanceof AppError) throw error;

      throw new AppError(500, 'auth_key_not_found', 'error', {
        ...(error instanceof Error ? { originalError: error } : {}),
      });
    }
  })
  /**
   * Unsubscribe myself by token from receiving newsletters
   */
  .openapi(meRoutes.unsubscribeMe, async (ctx) => {
    const { token } = ctx.req.valid('query');

    // Check if token exists
    const [user] = await db
      .select(userSelect)
      .from(usersTable)
      .innerJoin(unsubscribeTokensTable, eq(usersTable.id, unsubscribeTokensTable.userId))
      .where(eq(unsubscribeTokensTable.secret, token))
      .limit(1);

    if (!user) throw new AppError(404, 'not_found', 'warn', { entityType: 'user' });

    // Verify token
    const isValid = verifyUnsubscribeToken(user.email, token);
    if (!isValid) throw new AppError(401, 'unsubscribe_failed', 'warn', { entityType: 'user' });

    // Update user
    await db.update(usersTable).set({ newsletter: false }).where(eq(usersTable.id, user.id));

    const redirectUrl = new URL('/auth/unsubscribed', appConfig.frontendUrl);
    return ctx.redirect(redirectUrl, 302);
  })
  /**
   * Get all memberships for the current user
   */
  .openapi(meRoutes.getMyMemberships, async (ctx) => {
    const memberships = ctx.var.memberships;

    // Strip createdBy (not in membershipBaseSchema) â€” the rest already matches MembershipBaseModel
    const items = memberships.map(({ createdBy, ...rest }) => rest);

    return ctx.json({ items }, 200);
  });

export default meRouteHandlers;
