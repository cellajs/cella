/**
 * Generate CDC Migration Script
 *
 * This script generates SQL for setting up PostgreSQL logical replication
 * for the CDC (Change Data Capture) worker.
 *
 * Usage:
 *   pnpm generate:cdc-migration
 *
 * The migration is added to Drizzle's migration folder and journal,
 * so it will be applied automatically with other migrations.
 */

import { readFileSync, writeFileSync } from 'node:fs';
import { join } from 'node:path';
import { CDC_PUBLICATION_NAME, CDC_SLOT_NAME } from '../../cdc/src/constants';
import { entityTables } from '#/entity-config';
import { resourceTables } from '#/activities-config';
import { getTableName } from 'drizzle-orm';
import chalk from 'chalk';

// Build table names directly from backend imports
const trackedTableNames = [
  ...Object.values(entityTables).map((t) => getTableName(t)),
  ...Object.values(resourceTables).map((t) => getTableName(t)),
];

if (trackedTableNames.length === 0) {
  console.error(chalk.redBright.bold('✘ No tracked tables found for CDC!'));
  console.error('  Please ensure that entityTables and resourceTables are defined correctly.');
  process.exit(1);
}

const tableList = trackedTableNames.join(', ');

const migrationSql = `-- CDC (Change Data Capture) Setup Migration
-- Generated by: pnpm generate:cdc-migration
-- 
-- This migration sets up PostgreSQL logical replication for the activities CDC worker.
-- Prerequisites:
--   - PostgreSQL must be started with wal_level=logical (configured in compose.yaml)
--   - max_wal_senders and max_replication_slots must be > 0
--
-- NOTE: The replication slot is created by the CDC worker on startup, not in this migration.
-- This is because pg_create_logical_replication_slot cannot run in a transaction with writes.

-- ============================================================================
-- PUBLICATION
-- ============================================================================
-- Create a publication for the tables we want to track.
-- NOTE: The 'activities' table is intentionally excluded to prevent infinite loops.

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_publication WHERE pubname = '${CDC_PUBLICATION_NAME}') THEN
    CREATE PUBLICATION ${CDC_PUBLICATION_NAME} FOR TABLE ${tableList};
    RAISE NOTICE 'Created publication ${CDC_PUBLICATION_NAME}';
  ELSE
    RAISE NOTICE 'Publication ${CDC_PUBLICATION_NAME} already exists';
  END IF;
END $$;

-- ============================================================================
-- REPLICA IDENTITY
-- ============================================================================
-- Set REPLICA IDENTITY FULL on tracked tables to get old row values on UPDATE/DELETE.
-- This is required for the CDC worker to compute changedKeys accurately.

${trackedTableNames.map((table) => `ALTER TABLE ${table} REPLICA IDENTITY FULL;`).join('\n')}

-- ============================================================================
-- NOTES
-- ============================================================================
-- 
-- The replication slot '${CDC_SLOT_NAME}' is created automatically by the CDC worker.
--
-- To check the publication:
--   SELECT * FROM pg_publication;
--   SELECT * FROM pg_publication_tables WHERE pubname = '${CDC_PUBLICATION_NAME}';
--
-- To check the replication slot (after CDC worker has started):
--   SELECT * FROM pg_replication_slots WHERE slot_name = '${CDC_SLOT_NAME}';
--
-- To drop the publication (if needed):
--   DROP PUBLICATION IF EXISTS ${CDC_PUBLICATION_NAME};
--
-- To drop the replication slot (if needed):
--   SELECT pg_drop_replication_slot('${CDC_SLOT_NAME}');
--
-- WARNING: If the CDC worker is not running, the replication slot will accumulate
-- WAL data. Monitor with: SELECT pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) 
-- FROM pg_replication_slots WHERE slot_name = '${CDC_SLOT_NAME}';
`;

const drizzleDir = join(import.meta.dirname, '../drizzle');
const journalPath = join(drizzleDir, 'meta/_journal.json');

// Read the current journal
const journal = JSON.parse(readFileSync(journalPath, 'utf-8')) as {
  version: string;
  dialect: string;
  entries: Array<{ idx: number; version: string; when: number; tag: string; breakpoints: boolean }>;
};

// Check if CDC migration already exists
const cdcMigrationTag = 'cdc_setup';
const existingCdcEntry = journal.entries.find((e) => e.tag.endsWith(cdcMigrationTag));

if (existingCdcEntry) {
  // Update existing migration file
  const existingFilename = `${existingCdcEntry.tag}.sql`;
  const existingPath = join(drizzleDir, existingFilename);

  writeFileSync(existingPath, migrationSql);

  console.info('');
  console.info(`${chalk.greenBright.bold('✔')} CDC migration updated!`);
  console.info('');
  console.info(`  Updated: drizzle/${existingFilename}`);
} else {
  // Create new migration with Drizzle naming convention
  const nextIdx = journal.entries.length;
  const migrationTag = `${String(nextIdx).padStart(4, '0')}_${cdcMigrationTag}`;
  const filename = `${migrationTag}.sql`;
  const outputPath = join(drizzleDir, filename);

  // Write the migration file
  writeFileSync(outputPath, migrationSql);

  // Add entry to journal
  journal.entries.push({
    idx: nextIdx,
    version: journal.version,
    when: Date.now(),
    tag: migrationTag,
    breakpoints: true,
  });

  writeFileSync(journalPath, JSON.stringify(journal, null, 2));

  console.info('');
  console.info(`${chalk.greenBright.bold('✔')} CDC migration generated and added to Drizzle journal!`);
  console.info('');
  console.info(`  Output: drizzle/${filename}`);
}

console.info('');
console.info(`  ${chalk.greenBright.bold('Tracked tables:')}`);
for (const table of trackedTableNames) {
  console.info(`    - ${table}`);
}
